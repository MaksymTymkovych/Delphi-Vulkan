(*
** Copyright (c) 2015-2016 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*)

(*
** Delphi-Vulkan
**
** Copyright (c) 2016 Maksym Tymkovych
*)

unit vulkan;

interface

{$INCLUDE 'Vulkan.inc'}

uses  vk_platform
{$IFDEF VK_USE_PLATFORM_ANDROID_KHR}
//<android/native_window.h>;
{$ENDIF}

{$IFDEF VK_USE_PLATFORM_MIR_KHR}
//<mir_toolkit/client_types.h>;
{$ENDIF}

{$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
//<wayland-client.h>;
{$ENDIF}

{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
, Windows
{$ENDIF}

{$IFDEF VK_USE_PLATFORM_XLIB_KHR}
//<X11/Xlib.h>;
{$ENDIF}

{$IFDEF VK_USE_PLATFORM_XCB_KHR}
//<xcb/xcb.h>;
{$ENDIF}
;

{$IFDEF VK_USE_PLATFORM_ANDROID_KHR}
  VulkanLibName = 'libvulkan.so';
{$ENDIF}
{$IFDEF VK_USE_PLATFORM_MIR_KHR}
  //VulkanLibName = '';
{$ENDIF}
{$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
  VulkanLibName = 'libvulkan.so.1';
{$ENDIF}
{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
const
  VulkanLibName = 'vulkan-1-1-0-2-0.dll';
{$ENDIF}
{$IFDEF VK_USE_PLATFORM_XLIB_KHR}
  VulkanLibName = 'libvulkan.so';
{$ENDIF}
{$IFDEF VK_USE_PLATFORM_XCB_KHR}
  VulkanLibName = 'libvulkan.so';
{$ENDIF}

function VK_MAKE_VERSION(const major, minor, patch: Integer): Integer;

// Vulkan API version supported by this file
function VK_API_VERSION(): Integer;

function VK_VERSION_MAJOR(version: Cardinal): Integer;
function VK_VERSION_MINOR(version: Cardinal): Integer;
function VK_VERSION_PATCH(version: Cardinal): Integer;


const
  VK_NULL_HANDLE = 0;
        

{
#define VK_DEFINE_HANDLE(object) typedef struct object##_T* object;


#if defined(__LP64__) || defined(_WIN64) || defined(__x86_64__) || defined(_M_X64) || defined(__ia64) || defined (_M_IA64) || defined(__aarch64__) || defined(__powerpc64__)
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef struct object##_T *object;
#else
        #define VK_DEFINE_NON_DISPATCHABLE_HANDLE(object) typedef uint64_t object;
#endif
}

type
  PVkFlags = ^TVkFlags;
  TVkFlags = Cardinal;

  PVkBool32 = ^TVkBool32;
  TVkBool32 = Cardinal;

  PVkDeviceSize = ^TVkDeviceSize;
  TVkDeviceSize = {$IFNDEF DEFINE_UINT64_EQU_INT64} UInt64;{$ELSE} Int64;{$ENDIF}

  PVkSampleMask = ^TVkSampleMask;
  TVkSampleMask = Cardinal;

  PPVkInstance = ^PVkInstance;
  PVkInstance = ^TVkInstance;
  TVkInstance = record
  end;

  PPVkPhysicalDevice = ^PVkPhysicalDevice;
  PVkPhysicalDevice = ^TVkPhysicalDevice;
  TVkPhysicalDevice = record
  end;

  PPVkDevice = ^PVkDevice;
  PVkDevice = ^TVkDevice;
  TVkDevice = record
  end;

  PPVkQueue = ^PVkQueue;
  PVkQueue = ^TVkQueue;
  TVkQueue = record
  end;

  PPVkSemaphore = ^PVkSemaphore;
  PVkSemaphore = ^TVkSemaphore;
  TVkSemaphore = record
  end;

  PPVkCommandBuffer = ^PVkCommandBuffer;
  PVkCommandBuffer = ^TVkCommandBuffer;
  TVkCommandBuffer = record
  end;

  PPVkFence = ^PVkFence;
  PVkFence = ^TVkFence;
  TVkFence = record
  end;

  PPVkDeviceMemory = ^PVkDeviceMemory;
  PVkDeviceMemory = ^TVkDeviceMemory;
  TVkDeviceMemory = record
  end;

  PPVkBuffer = ^PVkBuffer;
  PVkBuffer = ^TVkBuffer;
  TVkBuffer = record
  end;

  PPVkImage = ^PVkImage;
  PVkImage = ^TVkImage;
  TVkImage = record
  end;

  PPVkEvent = ^PVkEvent;
  PVkEvent = ^TVkEvent;
  TVkEvent = record
  end;

  PPVkQueryPool = ^PVkQueryPool;
  PVkQueryPool = ^TVkQueryPool;
  TVkQueryPool = record
  end;

  PPVkBufferView = ^PVkBufferView;
  PVkBufferView = ^TVkBufferView;
  TVkBufferView = record
  end;

  PPVkImageView = ^PVkImageView;
  PVkImageView = ^TVkImageView;
  TVkImageView = record
  end;

  PPVkShaderModule = ^PVkShaderModule;
  PVkShaderModule = ^TVkShaderModule;
  TVkShaderModule = record
  end;

  PPVkPipelineCache = ^PVkPipelineCache;
  PVkPipelineCache = ^TVkPipelineCache;
  TVkPipelineCache = record
  end;

  PPVkPipelineLayout = ^PVkPipelineLayout;
  PVkPipelineLayout = ^TVkPipelineLayout;
  TVkPipelineLayout = record
  end;

  PPVkRenderPass = ^PVkRenderPass;
  PVkRenderPass = ^TVkRenderPass;
  TVkRenderPass = record
  end;

  PPVkPipeline = ^PVkPipeline;
  PVkPipeline = ^TVkPipeline;
  TVkPipeline = record
  end;

  PPVkDescriptorSetLayout = ^PVkDescriptorSetLayout;
  PVkDescriptorSetLayout = ^TVkDescriptorSetLayout;
  TVkDescriptorSetLayout = record
  end;

  PPVkSampler = ^PVkSampler;
  PVkSampler = ^TVkSampler;
  TVkSampler = record
  end;

  PPVkDescriptorPool = ^PVkDescriptorPool;
  PVkDescriptorPool = ^TVkDescriptorPool;
  TVkDescriptorPool = record
  end;

  PPVkDescriptorSet = ^PVkDescriptorSet;
  PVkDescriptorSet = ^TVkDescriptorSet;
  TVkDescriptorSet = record
  end;

  PPVkFramebuffer = ^PVkFramebuffer;
  PVkFramebuffer = ^TVkFramebuffer;
  TVkFramebuffer = record
  end;

  PPVkCommandPool = ^PVkCommandPool;
  PVkCommandPool = ^TVkCommandPool;
  TVkCommandPool = record
  end;

const
  VK_LOD_CLAMP_NONE = 1000.0;
  VK_REMAINING_MIP_LEVELS           = (not 0); // Cardinal
  VK_REMAINING_ARRAY_LAYERS         = (not 0); // Cardinal
  VK_WHOLE_SIZE                     = (not 0); // UINT64?
  VK_ATTACHMENT_UNUSED              = (not 0); // Cardinal
  VK_TRUE                           = 1;
  VK_FALSE                          = 0;
  VK_QUEUE_FAMILY_IGNORED           = (not 0); // Cardinal
  VK_SUBPASS_EXTERNAL               = (not 0); // Cardinal
  VK_MAX_PHYSICAL_DEVICE_NAME_SIZE  = 256;
  VK_UUID_SIZE                      = 16;
  VK_MAX_MEMORY_TYPES               = 32;
  VK_MAX_MEMORY_HEAPS               = 16;
  VK_MAX_EXTENSION_NAME_SIZE        = 256;
  VK_MAX_DESCRIPTION_SIZE           = 256;

type
  PVkPipelineCacheHeaderVersion = ^TVkPipelineCacheHeaderVersion;
  TVkPipelineCacheHeaderVersion = (
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE = VK_PIPELINE_CACHE_HEADER_VERSION_ONE,
    VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE = (VK_PIPELINE_CACHE_HEADER_VERSION_ONE - VK_PIPELINE_CACHE_HEADER_VERSION_ONE + 1),
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = $7FFFFFFF
  );

  PVkResult = ^TVkResult;
  TVkResult = (
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_RESULT_BEGIN_RANGE = VK_ERROR_FORMAT_NOT_SUPPORTED,
    VK_RESULT_END_RANGE = VK_INCOMPLETE,
    VK_RESULT_RANGE_SIZE = (VK_INCOMPLETE - VK_ERROR_FORMAT_NOT_SUPPORTED + 1),
    VK_RESULT_MAX_ENUM = $7FFFFFFF
  );

  PVkStructureType = ^TVkStructureType;
  TVkStructureType = (
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_BEGIN_RANGE = VK_STRUCTURE_TYPE_APPLICATION_INFO,
    VK_STRUCTURE_TYPE_END_RANGE = VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_RANGE_SIZE = (VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO - VK_STRUCTURE_TYPE_APPLICATION_INFO + 1),
    VK_STRUCTURE_TYPE_MAX_ENUM = $7FFFFFFF
  );

  PVkSystemAllocationScope = ^TVkSystemAllocationScope;
  TVkSystemAllocationScope = (
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_COMMAND,
    VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE = VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE,
    VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = (VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE - VK_SYSTEM_ALLOCATION_SCOPE_COMMAND + 1),
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = $7FFFFFFF
  );

  PVkInternalAllocationType = ^TVkInternalAllocationType;
  TVkInternalAllocationType = (
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_END_RANGE = VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE,
    VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = (VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE - VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE + 1),
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = $7FFFFFFF
  );

  PVkFormat = ^TVkFormat;
  TVkFormat = (
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_BEGIN_RANGE = VK_FORMAT_UNDEFINED,
    VK_FORMAT_END_RANGE = VK_FORMAT_ASTC_12x12_SRGB_BLOCK,
    VK_FORMAT_RANGE_SIZE = (VK_FORMAT_ASTC_12x12_SRGB_BLOCK - VK_FORMAT_UNDEFINED + 1),
    VK_FORMAT_MAX_ENUM = $7FFFFFFF
  );

  PVkImageType = ^TVkImageType;
  TVkImageType = (
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_BEGIN_RANGE = VK_IMAGE_TYPE_1D,
    VK_IMAGE_TYPE_END_RANGE = VK_IMAGE_TYPE_3D,
    VK_IMAGE_TYPE_RANGE_SIZE = (VK_IMAGE_TYPE_3D - VK_IMAGE_TYPE_1D + 1),
    VK_IMAGE_TYPE_MAX_ENUM = $7FFFFFFF
  );

  PVkImageTiling = ^TVkImageTiling;
  TVkImageTiling = (
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_BEGIN_RANGE = VK_IMAGE_TILING_OPTIMAL,
    VK_IMAGE_TILING_END_RANGE = VK_IMAGE_TILING_LINEAR,
    VK_IMAGE_TILING_RANGE_SIZE = (VK_IMAGE_TILING_LINEAR - VK_IMAGE_TILING_OPTIMAL + 1),
    VK_IMAGE_TILING_MAX_ENUM = $7FFFFFFF
  );

  PVkPhysicalDeviceType = ^TVkPhysicalDeviceType;
  TVkPhysicalDeviceType = (
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE = VK_PHYSICAL_DEVICE_TYPE_OTHER,
    VK_PHYSICAL_DEVICE_TYPE_END_RANGE = VK_PHYSICAL_DEVICE_TYPE_CPU,
    VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = (VK_PHYSICAL_DEVICE_TYPE_CPU - VK_PHYSICAL_DEVICE_TYPE_OTHER + 1),
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = $7FFFFFFF
  );

  PVkQueryType = ^TVkQueryType;
  TVkQueryType = (
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_BEGIN_RANGE = VK_QUERY_TYPE_OCCLUSION,
    VK_QUERY_TYPE_END_RANGE = VK_QUERY_TYPE_TIMESTAMP,
    VK_QUERY_TYPE_RANGE_SIZE = (VK_QUERY_TYPE_TIMESTAMP - VK_QUERY_TYPE_OCCLUSION + 1),
    VK_QUERY_TYPE_MAX_ENUM = $7FFFFFFF
  );

  PVkSharingMode = ^TVkSharingMode;
  TVkSharingMode = (
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_BEGIN_RANGE = VK_SHARING_MODE_EXCLUSIVE,
    VK_SHARING_MODE_END_RANGE = VK_SHARING_MODE_CONCURRENT,
    VK_SHARING_MODE_RANGE_SIZE = (VK_SHARING_MODE_CONCURRENT - VK_SHARING_MODE_EXCLUSIVE + 1),
    VK_SHARING_MODE_MAX_ENUM = $7FFFFFFF
  );

  PVkImageLayout = ^TVkImageLayout;
  TVkImageLayout = (
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_BEGIN_RANGE = VK_IMAGE_LAYOUT_UNDEFINED,
    VK_IMAGE_LAYOUT_END_RANGE = VK_IMAGE_LAYOUT_PREINITIALIZED,
    VK_IMAGE_LAYOUT_RANGE_SIZE = (VK_IMAGE_LAYOUT_PREINITIALIZED - VK_IMAGE_LAYOUT_UNDEFINED + 1),
    VK_IMAGE_LAYOUT_MAX_ENUM = $7FFFFFFF
  );

  PVkImageViewType = ^TVkImageViewType;
  TVkImageViewType = (
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_BEGIN_RANGE = VK_IMAGE_VIEW_TYPE_1D,
    VK_IMAGE_VIEW_TYPE_END_RANGE = VK_IMAGE_VIEW_TYPE_CUBE_ARRAY,
    VK_IMAGE_VIEW_TYPE_RANGE_SIZE = (VK_IMAGE_VIEW_TYPE_CUBE_ARRAY - VK_IMAGE_VIEW_TYPE_1D + 1),
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = $7FFFFFFF
  );

  PVkComponentSwizzle = ^TVkComponentSwizzle;
  TVkComponentSwizzle = (
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_BEGIN_RANGE = VK_COMPONENT_SWIZZLE_IDENTITY,
    VK_COMPONENT_SWIZZLE_END_RANGE = VK_COMPONENT_SWIZZLE_A,
    VK_COMPONENT_SWIZZLE_RANGE_SIZE = (VK_COMPONENT_SWIZZLE_A - VK_COMPONENT_SWIZZLE_IDENTITY + 1),
    VK_COMPONENT_SWIZZLE_MAX_ENUM = $7FFFFFFF
  );

  PVkVertexInputRate = ^TVkVertexInputRate;
  TVkVertexInputRate = (
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_BEGIN_RANGE = VK_VERTEX_INPUT_RATE_VERTEX,
    VK_VERTEX_INPUT_RATE_END_RANGE = VK_VERTEX_INPUT_RATE_INSTANCE,
    VK_VERTEX_INPUT_RATE_RANGE_SIZE = (VK_VERTEX_INPUT_RATE_INSTANCE - VK_VERTEX_INPUT_RATE_VERTEX + 1),
    VK_VERTEX_INPUT_RATE_MAX_ENUM = $7FFFFFFF
  );

  PVkPrimitiveTopology = ^TVkPrimitiveTopology;
  TVkPrimitiveTopology = (
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE = VK_PRIMITIVE_TOPOLOGY_POINT_LIST,
    VK_PRIMITIVE_TOPOLOGY_END_RANGE = VK_PRIMITIVE_TOPOLOGY_PATCH_LIST,
    VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = (VK_PRIMITIVE_TOPOLOGY_PATCH_LIST - VK_PRIMITIVE_TOPOLOGY_POINT_LIST + 1),
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = $7FFFFFFF
  );

  PVkPolygonMode = ^TVkPolygonMode;
  TVkPolygonMode = (
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_BEGIN_RANGE = VK_POLYGON_MODE_FILL,
    VK_POLYGON_MODE_END_RANGE = VK_POLYGON_MODE_POINT,
    VK_POLYGON_MODE_RANGE_SIZE = (VK_POLYGON_MODE_POINT - VK_POLYGON_MODE_FILL + 1),
    VK_POLYGON_MODE_MAX_ENUM = $7FFFFFFF
  );

  PVkFrontFace = ^TVkFrontFace;
  TVkFrontFace = (
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_BEGIN_RANGE = VK_FRONT_FACE_COUNTER_CLOCKWISE,
    VK_FRONT_FACE_END_RANGE = VK_FRONT_FACE_CLOCKWISE,
    VK_FRONT_FACE_RANGE_SIZE = (VK_FRONT_FACE_CLOCKWISE - VK_FRONT_FACE_COUNTER_CLOCKWISE + 1),
    VK_FRONT_FACE_MAX_ENUM = $7FFFFFFF
  );

  PVkCompareOp = ^TVkCompareOp;
  TVkCompareOp = (
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_BEGIN_RANGE = VK_COMPARE_OP_NEVER,
    VK_COMPARE_OP_END_RANGE = VK_COMPARE_OP_ALWAYS,
    VK_COMPARE_OP_RANGE_SIZE = (VK_COMPARE_OP_ALWAYS - VK_COMPARE_OP_NEVER + 1),
    VK_COMPARE_OP_MAX_ENUM = $7FFFFFFF
  );

  PVkStencilOp = ^TVkStencilOp;
  TVkStencilOp = (
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_BEGIN_RANGE = VK_STENCIL_OP_KEEP,
    VK_STENCIL_OP_END_RANGE = VK_STENCIL_OP_DECREMENT_AND_WRAP,
    VK_STENCIL_OP_RANGE_SIZE = (VK_STENCIL_OP_DECREMENT_AND_WRAP - VK_STENCIL_OP_KEEP + 1),
    VK_STENCIL_OP_MAX_ENUM = $7FFFFFFF
  );

  PVkLogicOp = ^TVkLogicOp;
  TVkLogicOp = (
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_BEGIN_RANGE = VK_LOGIC_OP_CLEAR,
    VK_LOGIC_OP_END_RANGE = VK_LOGIC_OP_SET,
    VK_LOGIC_OP_RANGE_SIZE = (VK_LOGIC_OP_SET - VK_LOGIC_OP_CLEAR + 1),
    VK_LOGIC_OP_MAX_ENUM = $7FFFFFFF
  );

  PVkBlendFactor = ^TVkBlendFactor;
  TVkBlendFactor = (
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_BEGIN_RANGE = VK_BLEND_FACTOR_ZERO,
    VK_BLEND_FACTOR_END_RANGE = VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA,
    VK_BLEND_FACTOR_RANGE_SIZE = (VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA - VK_BLEND_FACTOR_ZERO + 1),
    VK_BLEND_FACTOR_MAX_ENUM = $7FFFFFFF
  );

  PVkBlendOp = ^TVkBlendOp;
  TVkBlendOp = (
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_BEGIN_RANGE = VK_BLEND_OP_ADD,
    VK_BLEND_OP_END_RANGE = VK_BLEND_OP_MAX,
    VK_BLEND_OP_RANGE_SIZE = (VK_BLEND_OP_MAX - VK_BLEND_OP_ADD + 1),
    VK_BLEND_OP_MAX_ENUM = $7FFFFFFF
  );

  PVkDynamicState = ^TVkDynamicState;
  TVkDynamicState = (
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_BEGIN_RANGE = VK_DYNAMIC_STATE_VIEWPORT,
    VK_DYNAMIC_STATE_END_RANGE = VK_DYNAMIC_STATE_STENCIL_REFERENCE,
    VK_DYNAMIC_STATE_RANGE_SIZE = (VK_DYNAMIC_STATE_STENCIL_REFERENCE - VK_DYNAMIC_STATE_VIEWPORT + 1),
    VK_DYNAMIC_STATE_MAX_ENUM = $7FFFFFFF
  );

  PVkFilter = ^TVkFilter;
  TVkFilter = (
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_BEGIN_RANGE = VK_FILTER_NEAREST,
    VK_FILTER_END_RANGE = VK_FILTER_LINEAR,
    VK_FILTER_RANGE_SIZE = (VK_FILTER_LINEAR - VK_FILTER_NEAREST + 1),
    VK_FILTER_MAX_ENUM = $7FFFFFFF
  );

  PVkSamplerMipmapMode = ^TVkSamplerMipmapMode;
  TVkSamplerMipmapMode = (
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE = VK_SAMPLER_MIPMAP_MODE_NEAREST,
    VK_SAMPLER_MIPMAP_MODE_END_RANGE = VK_SAMPLER_MIPMAP_MODE_LINEAR,
    VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = (VK_SAMPLER_MIPMAP_MODE_LINEAR - VK_SAMPLER_MIPMAP_MODE_NEAREST + 1),
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = $7FFFFFFF
  );

  PVkSamplerAddressMode = ^TVkSamplerAddressMode;
  TVkSamplerAddressMode = (
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE = VK_SAMPLER_ADDRESS_MODE_REPEAT,
    VK_SAMPLER_ADDRESS_MODE_END_RANGE = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE,
    VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE = (VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE - VK_SAMPLER_ADDRESS_MODE_REPEAT + 1),
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = $7FFFFFFF
  );

  PVkBorderColor = ^TVkBorderColor;
  TVkBorderColor = (
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_BEGIN_RANGE = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,
    VK_BORDER_COLOR_END_RANGE = VK_BORDER_COLOR_INT_OPAQUE_WHITE,
    VK_BORDER_COLOR_RANGE_SIZE = (VK_BORDER_COLOR_INT_OPAQUE_WHITE - VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK + 1),
    VK_BORDER_COLOR_MAX_ENUM = $7FFFFFFF
  );

  PVkDescriptorType = ^TVkDescriptorType;
  TVkDescriptorType = (
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_BEGIN_RANGE = VK_DESCRIPTOR_TYPE_SAMPLER,
    VK_DESCRIPTOR_TYPE_END_RANGE = VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT,
    VK_DESCRIPTOR_TYPE_RANGE_SIZE = (VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT - VK_DESCRIPTOR_TYPE_SAMPLER + 1),
    VK_DESCRIPTOR_TYPE_MAX_ENUM = $7FFFFFFF
  );

  PVkAttachmentLoadOp = ^TVkAttachmentLoadOp;
  TVkAttachmentLoadOp = (
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE = VK_ATTACHMENT_LOAD_OP_LOAD,
    VK_ATTACHMENT_LOAD_OP_END_RANGE = VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = (VK_ATTACHMENT_LOAD_OP_DONT_CARE - VK_ATTACHMENT_LOAD_OP_LOAD + 1),
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = $7FFFFFFF
  );

  PVkAttachmentStoreOp = ^TVkAttachmentStoreOp;
  TVkAttachmentStoreOp = (
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_BEGIN_RANGE = VK_ATTACHMENT_STORE_OP_STORE,
    VK_ATTACHMENT_STORE_OP_END_RANGE = VK_ATTACHMENT_STORE_OP_DONT_CARE,
    VK_ATTACHMENT_STORE_OP_RANGE_SIZE = (VK_ATTACHMENT_STORE_OP_DONT_CARE - VK_ATTACHMENT_STORE_OP_STORE + 1),
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = $7FFFFFFF
  );

  PVkPipelineBindPoint = ^TVkPipelineBindPoint;
  TVkPipelineBindPoint = (
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_BEGIN_RANGE = VK_PIPELINE_BIND_POINT_GRAPHICS,
    VK_PIPELINE_BIND_POINT_END_RANGE = VK_PIPELINE_BIND_POINT_COMPUTE,
    VK_PIPELINE_BIND_POINT_RANGE_SIZE = (VK_PIPELINE_BIND_POINT_COMPUTE - VK_PIPELINE_BIND_POINT_GRAPHICS + 1),
    VK_PIPELINE_BIND_POINT_MAX_ENUM = $7FFFFFFF
  );

  PVkCommandBufferLevel = ^TVkCommandBufferLevel;
  TVkCommandBufferLevel = (
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
    VK_COMMAND_BUFFER_LEVEL_END_RANGE = VK_COMMAND_BUFFER_LEVEL_SECONDARY,
    VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = (VK_COMMAND_BUFFER_LEVEL_SECONDARY - VK_COMMAND_BUFFER_LEVEL_PRIMARY + 1),
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = $7FFFFFFF
  );

  PVkIndexType = ^TVkIndexType;
  TVkIndexType = (
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_BEGIN_RANGE = VK_INDEX_TYPE_UINT16,
    VK_INDEX_TYPE_END_RANGE = VK_INDEX_TYPE_UINT32,
    VK_INDEX_TYPE_RANGE_SIZE = (VK_INDEX_TYPE_UINT32 - VK_INDEX_TYPE_UINT16 + 1),
    VK_INDEX_TYPE_MAX_ENUM = $7FFFFFFF
  );

  PVkSubpassContents = ^TVkSubpassContents;
  TVkSubpassContents = (
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_BEGIN_RANGE = VK_SUBPASS_CONTENTS_INLINE,
    VK_SUBPASS_CONTENTS_END_RANGE = VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS,
    VK_SUBPASS_CONTENTS_RANGE_SIZE = (VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS - VK_SUBPASS_CONTENTS_INLINE + 1),
    VK_SUBPASS_CONTENTS_MAX_ENUM = $7FFFFFFF
  );

  PVkInstanceCreateFlags = ^TVkInstanceCreateFlags;
  TVkInstanceCreateFlags = TVkFlags;

  PVkFormatFeatureFlagBits = ^TVkFormatFeatureFlagBits;
  TVkFormatFeatureFlagBits = (
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = $00000001,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = $00000002,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = $00000004,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = $00000008,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = $00000010,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = $00000020,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = $00000040,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = $00000080,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = $00000100,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = $00000200,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = $00000400,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = $00000800,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = $00001000
  );

  PVkFormatFeatureFlags = ^TVkFormatFeatureFlags;
  TVkFormatFeatureFlags = TVkFlags;

  PVkImageUsageFlagBits = ^TVkImageUsageFlagBits;
  TVkImageUsageFlagBits = (
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = $00000001,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = $00000002,
    VK_IMAGE_USAGE_SAMPLED_BIT = $00000004,
    VK_IMAGE_USAGE_STORAGE_BIT = $00000008,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = $00000010,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = $00000020,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = $00000040,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = $00000080
  );

  PVkImageUsageFlags = ^TVkImageUsageFlags;
  TVkImageUsageFlags = TVkFlags;

  PVkImageCreateFlagBits = ^TVkImageCreateFlagBits;
  TVkImageCreateFlagBits = (
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = $00000001,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = $00000002,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = $00000004,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = $00000008,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = $00000010
  );

  PVkImageCreateFlags = ^TVkImageCreateFlags;
  TVkImageCreateFlags = TVkFlags;

  PVkSampleCountFlagBits = ^TVkSampleCountFlagBits;
  TVkSampleCountFlagBits  = (
    VK_SAMPLE_COUNT_1_BIT = $00000001,
    VK_SAMPLE_COUNT_2_BIT = $00000002,
    VK_SAMPLE_COUNT_4_BIT = $00000004,
    VK_SAMPLE_COUNT_8_BIT = $00000008,
    VK_SAMPLE_COUNT_16_BIT = $00000010,
    VK_SAMPLE_COUNT_32_BIT = $00000020,
    VK_SAMPLE_COUNT_64_BIT = $00000040
  );

  PVkSampleCountFlags = ^TVkSampleCountFlags;
  TVkSampleCountFlags = TVkFlags;

  PVkQueueFlagBits = ^TVkQueueFlagBits;
  TVkQueueFlagBits = (
    VK_QUEUE_GRAPHICS_BIT = $00000001,
    VK_QUEUE_COMPUTE_BIT = $00000002,
    VK_QUEUE_TRANSFER_BIT = $00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = $00000008
  );

  PVkQueueFlags = ^TVkQueueFlags;
  TVkQueueFlags = TVkFlags;

  PVkMemoryPropertyFlagBits = ^TVkMemoryPropertyFlagBits;
  TVkMemoryPropertyFlagBits = (
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = $00000001,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = $00000002,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = $00000004,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = $00000008,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = $00000010
  );

  PVkMemoryPropertyFlags = ^TVkMemoryPropertyFlags;
  TVkMemoryPropertyFlags = TVkFlags;

  PVkMemoryHeapFlagBits = ^TVkMemoryHeapFlagBits;
  TVkMemoryHeapFlagBits = (
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = $00000001
  );

  PVkMemoryHeapFlags = ^TVkMemoryHeapFlags;
  TVkMemoryHeapFlags = TVkFlags;

  PVkDeviceCreateFlags = ^TVkDeviceCreateFlags;
  TVkDeviceCreateFlags = TVkFlags;

  PVkDeviceQueueCreateFlags = ^TVkDeviceQueueCreateFlags;
  TVkDeviceQueueCreateFlags = TVkFlags;

  PVkPipelineStageFlagBits = ^TVkPipelineStageFlagBits;
  TVkPipelineStageFlagBits = (
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = $00000001,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = $00000002,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = $00000004,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = $00000008,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = $00000010,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = $00000020,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = $00000040,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = $00000080,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = $00000100,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = $00000200,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = $00000400,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = $00000800,
    VK_PIPELINE_STAGE_TRANSFER_BIT = $00001000,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = $00002000,
    VK_PIPELINE_STAGE_HOST_BIT = $00004000,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = $00008000,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = $00010000
  );

  PVkPipelineStageFlags = ^TVkPipelineStageFlags;
  TVkPipelineStageFlags = TVkFlags;

  PVkMemoryMapFlags = ^TVkMemoryMapFlags;
  TVkMemoryMapFlags = TVkFlags;

  PVkImageAspectFlagBits = ^TVkImageAspectFlagBits;
  TVkImageAspectFlagBits = (
    VK_IMAGE_ASPECT_COLOR_BIT = $00000001,
    VK_IMAGE_ASPECT_DEPTH_BIT = $00000002,
    VK_IMAGE_ASPECT_STENCIL_BIT = $00000004,
    VK_IMAGE_ASPECT_METADATA_BIT = $00000008
  );

  PVkImageAspectFlags = ^TVkImageAspectFlags;
  TVkImageAspectFlags = TVkFlags;

  PVkSparseImageFormatFlagBits = ^TVkSparseImageFormatFlagBits;
  TVkSparseImageFormatFlagBits = (
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = $00000001,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = $00000002,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = $00000004
  );

  PVkSparseImageFormatFlags = ^TVkSparseImageFormatFlags;
  TVkSparseImageFormatFlags = TVkFlags;

  PVkSparseMemoryBindFlagBits = ^TVkSparseMemoryBindFlagBits;
  TVkSparseMemoryBindFlagBits = (
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = $00000001
  );

  PVkSparseMemoryBindFlags = ^TVkSparseMemoryBindFlags;
  TVkSparseMemoryBindFlags = TVkFlags;

  PVkFenceCreateFlagBits = ^TVkFenceCreateFlagBits;
  TVkFenceCreateFlagBits = (
    VK_FENCE_CREATE_SIGNALED_BIT = $00000001
  );

  PVkFenceCreateFlags = ^TVkFenceCreateFlags;
  TVkFenceCreateFlags = TVkFlags;

  PVkSemaphoreCreateFlags = ^TVkSemaphoreCreateFlags;
  TVkSemaphoreCreateFlags = TVkFlags;

  PVkEventCreateFlags = ^TVkEventCreateFlags;
  TVkEventCreateFlags = TVkFlags;

  PVkQueryPoolCreateFlags = ^TVkQueryPoolCreateFlags;
  TVkQueryPoolCreateFlags = TVkFlags;

  PVkQueryPipelineStatisticFlagBits = ^TVkQueryPipelineStatisticFlagBits;
  TVkQueryPipelineStatisticFlagBits = (
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = $00000001,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = $00000002,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = $00000004,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = $00000008,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = $00000010,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = $00000020,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = $00000040,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = $00000080,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = $00000100,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = $00000200,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = $00000400
  );

  PVkQueryPipelineStatisticFlags = ^TVkQueryPipelineStatisticFlags;
  TVkQueryPipelineStatisticFlags = TVkFlags;

  PVkQueryResultFlagBits = ^TVkQueryResultFlagBits;
  TVkQueryResultFlagBits = (
    VK_QUERY_RESULT_64_BIT = $00000001,
    VK_QUERY_RESULT_WAIT_BIT = $00000002,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = $00000004,
    VK_QUERY_RESULT_PARTIAL_BIT = $00000008
  );

  PVkQueryResultFlags = ^TVkQueryResultFlags;
  TVkQueryResultFlags = TVkFlags;

  PVkBufferCreateFlagBits = ^TVkBufferCreateFlagBits;
  TVkBufferCreateFlagBits = (
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = $00000001,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = $00000002,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = $00000004
  );

  PVkBufferCreateFlags = ^TVkBufferCreateFlags;
  TVkBufferCreateFlags = TVkFlags;

  PVkBufferUsageFlagBits = ^TVkBufferUsageFlagBits;
  TVkBufferUsageFlagBits = (
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = $00000001,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = $00000002,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = $00000004,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = $00000008,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = $00000010,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = $00000020,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = $00000040,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = $00000080,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = $00000100
  );

  PVkBufferUsageFlags = ^TVkBufferUsageFlags;
  TVkBufferUsageFlags = TVkFlags;

  PVkBufferViewCreateFlags = ^TVkBufferViewCreateFlags;
  TVkBufferViewCreateFlags = TVkFlags;

  PVkImageViewCreateFlags = ^TVkImageViewCreateFlags;
  TVkImageViewCreateFlags = TVkFlags;

  PVkShaderModuleCreateFlags = ^TVkShaderModuleCreateFlags;
  TVkShaderModuleCreateFlags = TVkFlags;

  PVkPipelineCacheCreateFlags = ^TVkPipelineCacheCreateFlags;
  TVkPipelineCacheCreateFlags = TVkFlags;

  PVkPipelineCreateFlagBits = ^TVkPipelineCreateFlagBits;
  TVkPipelineCreateFlagBits = (
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = $00000001,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = $00000002,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = $00000004
  );

  PVkPipelineCreateFlags = ^TVkPipelineCreateFlags;
  TVkPipelineCreateFlags = TVkFlags;

  PVkPipelineShaderStageCreateFlags = ^TVkPipelineShaderStageCreateFlags;
  TVkPipelineShaderStageCreateFlags = TVkFlags;

  PVkShaderStageFlagBits = ^TVkShaderStageFlagBits;
  TVkShaderStageFlagBits = (
    VK_SHADER_STAGE_VERTEX_BIT = $00000001,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = $00000002,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = $00000004,
    VK_SHADER_STAGE_GEOMETRY_BIT = $00000008,
    VK_SHADER_STAGE_FRAGMENT_BIT = $00000010,
    VK_SHADER_STAGE_COMPUTE_BIT = $00000020,
    VK_SHADER_STAGE_ALL_GRAPHICS = $1F,
    VK_SHADER_STAGE_ALL = $7FFFFFFF
  );

  PVkPipelineVertexInputStateCreateFlags = ^TVkPipelineVertexInputStateCreateFlags;
  TVkPipelineVertexInputStateCreateFlags = TVkFlags;

  PVkPipelineInputAssemblyStateCreateFlags = ^TVkPipelineInputAssemblyStateCreateFlags;
  TVkPipelineInputAssemblyStateCreateFlags = TVkFlags;

  PVkPipelineTessellationStateCreateFlags = ^TVkPipelineTessellationStateCreateFlags;
  TVkPipelineTessellationStateCreateFlags = TVkFlags;

  PVkPipelineViewportStateCreateFlags = ^TVkPipelineViewportStateCreateFlags;
  TVkPipelineViewportStateCreateFlags = TVkFlags;

  PVkPipelineRasterizationStateCreateFlags = ^TVkPipelineRasterizationStateCreateFlags;
  TVkPipelineRasterizationStateCreateFlags = TVkFlags;

  PVkCullModeFlagBits = ^TVkCullModeFlagBits;
  TVkCullModeFlagBits = (
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = $00000001,
    VK_CULL_MODE_BACK_BIT = $00000002,
    VK_CULL_MODE_FRONT_AND_BACK = $3
  );

  PVkCullModeFlags = ^TVkCullModeFlags;
  TVkCullModeFlags = TVkFlags;

  PVkPipelineMultisampleStateCreateFlags = ^TVkPipelineMultisampleStateCreateFlags;
  TVkPipelineMultisampleStateCreateFlags = TVkFlags;

  PVkPipelineDepthStencilStateCreateFlags = ^TVkPipelineDepthStencilStateCreateFlags;
  TVkPipelineDepthStencilStateCreateFlags = TVkFlags;

  PVkPipelineColorBlendStateCreateFlags = ^TVkPipelineColorBlendStateCreateFlags;
  TVkPipelineColorBlendStateCreateFlags = TVkFlags;

  PVkColorComponentFlagBits = ^TVkColorComponentFlagBits;
  TVkColorComponentFlagBits = (
    VK_COLOR_COMPONENT_R_BIT = $00000001,
    VK_COLOR_COMPONENT_G_BIT = $00000002,
    VK_COLOR_COMPONENT_B_BIT = $00000004,
    VK_COLOR_COMPONENT_A_BIT = $00000008
  );

  PVkColorComponentFlags = ^TVkColorComponentFlags;
  TVkColorComponentFlags = TVkFlags;

  PVkPipelineDynamicStateCreateFlags = ^TVkPipelineDynamicStateCreateFlags;
  TVkPipelineDynamicStateCreateFlags = TVkFlags;

  PVkPipelineLayoutCreateFlags = ^TVkPipelineLayoutCreateFlags;
  TVkPipelineLayoutCreateFlags = TVkFlags;

  PVkShaderStageFlags = ^TVkShaderStageFlags;
  TVkShaderStageFlags = TVkFlags;

  PVkSamplerCreateFlags = ^TVkSamplerCreateFlags;
  TVkSamplerCreateFlags = TVkFlags;

  PVkDescriptorSetLayoutCreateFlags = ^TVkDescriptorSetLayoutCreateFlags;
  TVkDescriptorSetLayoutCreateFlags = TVkFlags;

  PVkDescriptorPoolCreateFlagBits = ^TVkDescriptorPoolCreateFlagBits;
  TVkDescriptorPoolCreateFlagBits = (
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = $00000001
  );

  PVkDescriptorPoolCreateFlags = ^TVkDescriptorPoolCreateFlags;
  TVkDescriptorPoolCreateFlags = TVkFlags;

  PVkDescriptorPoolResetFlags = ^TVkDescriptorPoolResetFlags;
  TVkDescriptorPoolResetFlags = TVkFlags;

  PVkFramebufferCreateFlags = ^TVkFramebufferCreateFlags;
  TVkFramebufferCreateFlags = TVkFlags;

  PVkRenderPassCreateFlags = ^TVkRenderPassCreateFlags;
  TVkRenderPassCreateFlags = TVkFlags;

  PVkAttachmentDescriptionFlagBits = ^TVkAttachmentDescriptionFlagBits;
  TVkAttachmentDescriptionFlagBits = (
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = $00000001
  );

  PVkAttachmentDescriptionFlags = ^TVkAttachmentDescriptionFlags;
  TVkAttachmentDescriptionFlags = TVkFlags;

  PVkSubpassDescriptionFlags = ^TVkSubpassDescriptionFlags;
  TVkSubpassDescriptionFlags = TVkFlags ;

  PVkAccessFlagBits = ^TVkAccessFlagBits;
  TVkAccessFlagBits = (
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = $00000001,
    VK_ACCESS_INDEX_READ_BIT = $00000002,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = $00000004,
    VK_ACCESS_UNIFORM_READ_BIT = $00000008,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = $00000010,
    VK_ACCESS_SHADER_READ_BIT = $00000020,
    VK_ACCESS_SHADER_WRITE_BIT = $00000040,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = $00000080,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = $00000100,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = $00000200,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = $00000400,
    VK_ACCESS_TRANSFER_READ_BIT = $00000800,
    VK_ACCESS_TRANSFER_WRITE_BIT = $00001000,
    VK_ACCESS_HOST_READ_BIT = $00002000,
    VK_ACCESS_HOST_WRITE_BIT = $00004000,
    VK_ACCESS_MEMORY_READ_BIT = $00008000,
    VK_ACCESS_MEMORY_WRITE_BIT = $00010000
  );

  PVkAccessFlags = ^TVkAccessFlags;
  TVkAccessFlags = TVkFlags;

  PVkDependencyFlagBits = ^TVkDependencyFlagBits;
  TVkDependencyFlagBits = (
    VK_DEPENDENCY_BY_REGION_BIT = $00000001
  );

  PVkDependencyFlags = ^TVkDependencyFlags;
  TVkDependencyFlags = TVkFlags;

  PVkCommandPoolCreateFlagBits = ^TVkCommandPoolCreateFlagBits;
  TVkCommandPoolCreateFlagBits = (
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = $00000001,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = $00000002
  );

  PVkCommandPoolCreateFlags = ^TVkCommandPoolCreateFlags;
  TVkCommandPoolCreateFlags = TVkFlags;

  PVkCommandPoolResetFlagBits = ^TVkCommandPoolResetFlagBits;
  TVkCommandPoolResetFlagBits = (
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = $00000001
  );

  PVkCommandPoolResetFlags = ^TVkCommandPoolResetFlags;
  TVkCommandPoolResetFlags = TVkFlags;

  PVkCommandBufferUsageFlagBits = ^TVkCommandBufferUsageFlagBits;
  TVkCommandBufferUsageFlagBits = (
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = $00000001,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = $00000002,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = $00000004
  );

  PVkCommandBufferUsageFlags = ^TVkCommandBufferUsageFlags;
  TVkCommandBufferUsageFlags = TVkFlags;

  PVkQueryControlFlagBits = ^TVkQueryControlFlagBits;
  TVkQueryControlFlagBits = (
    VK_QUERY_CONTROL_PRECISE_BIT = $00000001
  );

  PVkQueryControlFlags = ^TVkQueryControlFlags;
  TVkQueryControlFlags = TVkFlags;

  PVkCommandBufferResetFlagBits = ^TVkCommandBufferResetFlagBits;
  TVkCommandBufferResetFlagBits = (
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = $00000001
  );

  PVkCommandBufferResetFlags = ^TVkCommandBufferResetFlags;
  TVkCommandBufferResetFlags = TVkFlags;

  PVkStencilFaceFlagBits = ^TVkStencilFaceFlagBits;
  TVkStencilFaceFlagBits = (
    VK_STENCIL_FACE_FRONT_BIT = $00000001,
    VK_STENCIL_FACE_BACK_BIT = $00000002,
    VK_STENCIL_FRONT_AND_BACK = $3
  );

  PVkStencilFaceFlags = ^TVkStencilFaceFlags;
  TVkStencilFaceFlags = TVkFlags;

  TvkAllocationFunction = function (
                                pUserData: Pointer;
                                size: size_t;
                                alignment: size_t;
                                allocationScope: TVkSystemAllocationScope
                                ): Pointer; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkReallocationFunction = function (
                                pUserData: Pointer;
                                pOriginal: Pointer;
                                size: size_t;
                                alignment: size_t;
                                allocationScope: TVkSystemAllocationScope): Pointer; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFreeFunction = procedure (
                                pUserData: Pointer;
                                pMemory: Pointer); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkInternalAllocationNotification = procedure (
                                pUserData: Pointer;
                                size: size_t;
                                allocationType: TVkInternalAllocationType;
                                allocationScope: TVkSystemAllocationScope); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkInternalFreeNotification = procedure (
                                pUserData: Pointer;
                                size: size_t;
                                allocationType: TVkInternalAllocationType;
                                allocationScope: TVkSystemAllocationScope); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkVoidFunction = procedure(); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

type

  PVkApplicationInfo = ^TVkApplicationInfo;
  TVkApplicationInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    pApplicationName: PAnsiChar;
    applicationVersion: uint32_t;
    pEngineName: PAnsiChar;
    engineVersion: uint32_t;
    apiVersion: uint32_t;
  end;

  PVkInstanceCreateInfo = ^TVkInstanceCreateInfo;
  TVkInstanceCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkInstanceCreateFlags;
    pApplicationInfo: PVkApplicationInfo;
    enabledLayerCount: uint32_t;
    ppEnabledLayerNames: PPAnsiChar;
    enabledExtensionCount: uint32_t;
    ppEnabledExtensionNames: PPAnsiChar;
  end;

  PVkAllocationCallbacks = ^TVkAllocationCallbacks;
  TVkAllocationCallbacks = record
    pUserData: Pointer;
    pfnAllocation: TvkAllocationFunction;
    pfnReallocation: TvkReallocationFunction;
    pfnFree: TvkFreeFunction;
    pfnInternalAllocation: TvkInternalAllocationNotification;
    pfnInternalFree: TvkInternalFreeNotification;
  end;

  PVkPhysicalDeviceFeatures = ^TVkPhysicalDeviceFeatures;
  TVkPhysicalDeviceFeatures = record
    robustBufferAccess: TVkBool32;
    fullDrawIndexUint32: TVkBool32;
    imageCubeArray: TVkBool32;
    independentBlend: TVkBool32;
    geometryShader: TVkBool32;
    tessellationShader: TVkBool32;
    sampleRateShading: TVkBool32;
    dualSrcBlend: TVkBool32;
    logicOp: TVkBool32;
    multiDrawIndirect: TVkBool32;
    drawIndirectFirstInstance: TVkBool32;
    depthClamp: TVkBool32;
    depthBiasClamp: TVkBool32;
    fillModeNonSolid: TVkBool32;
    depthBounds: TVkBool32;
    wideLines: TVkBool32;
    largePoints: TVkBool32;
    alphaToOne: TVkBool32;
    multiViewport: TVkBool32;
    samplerAnisotropy: TVkBool32;
    textureCompressionETC2: TVkBool32;
    textureCompressionASTC_LDR: TVkBool32;
    textureCompressionBC: TVkBool32;
    occlusionQueryPrecise: TVkBool32;
    pipelineStatisticsQuery: TVkBool32;
    vertexPipelineStoresAndAtomics: TVkBool32;
    fragmentStoresAndAtomics: TVkBool32;
    shaderTessellationAndGeometryPointSize: TVkBool32;
    shaderImageGatherExtended: TVkBool32;
    shaderStorageImageExtendedFormats: TVkBool32;
    shaderStorageImageMultisample: TVkBool32;
    shaderStorageImageReadWithoutFormat: TVkBool32;
    shaderStorageImageWriteWithoutFormat: TVkBool32;
    shaderUniformBufferArrayDynamicIndexing: TVkBool32;
    shaderSampledImageArrayDynamicIndexing: TVkBool32;
    shaderStorageBufferArrayDynamicIndexing: TVkBool32;
    shaderStorageImageArrayDynamicIndexing: TVkBool32;
    shaderClipDistance: TVkBool32;
    shaderCullDistance: TVkBool32;
    shaderFloat64: TVkBool32;
    shaderInt64: TVkBool32;
    shaderInt16: TVkBool32;
    shaderResourceResidency: TVkBool32;
    shaderResourceMinLod: TVkBool32;
    sparseBinding: TVkBool32;
    sparseResidencyBuffer: TVkBool32;
    sparseResidencyImage2D: TVkBool32;
    sparseResidencyImage3D: TVkBool32;
    sparseResidency2Samples: TVkBool32;
    sparseResidency4Samples: TVkBool32;
    sparseResidency8Samples: TVkBool32;
    sparseResidency16Samples: TVkBool32;
    sparseResidencyAliased: TVkBool32;
    variableMultisampleRate: TVkBool32;
    inheritedQueries: TVkBool32;
  end;

  PVkFormatProperties = ^TVkFormatProperties;
  TVkFormatProperties = record
    linearTilingFeatures: TVkFormatFeatureFlags;
    optimalTilingFeatures: TVkFormatFeatureFlags;
    bufferFeatures: TVkFormatFeatureFlags;
  end;

  PVkExtent3D = ^TVkExtent3D;
  TVkExtent3D = record
    width: uint32_t;
    height: uint32_t;
    depth: uint32_t;
  end;

  PVkImageFormatProperties = ^TVkImageFormatProperties;
  TVkImageFormatProperties = record
    maxExtent: TVkExtent3D;
    maxMipLevels: uint32_t;
    maxArrayLayers: uint32_t;
    sampleCounts: TVkSampleCountFlags;
    maxResourceSize: TVkDeviceSize;
  end;

  PVkPhysicalDeviceLimits = ^TVkPhysicalDeviceLimits;
  TVkPhysicalDeviceLimits = record
    maxImageDimension1D: uint32_t;
    maxImageDimension2D: uint32_t;
    maxImageDimension3D: uint32_t;
    maxImageDimensionCube: uint32_t;
    maxImageArrayLayers: uint32_t;
    maxTexelBufferElements: uint32_t;
    maxUniformBufferRange: uint32_t;
    maxStorageBufferRange: uint32_t;
    maxPushConstantsSize: uint32_t;
    maxMemoryAllocationCount: uint32_t;
    maxSamplerAllocationCount: uint32_t;
    bufferImageGranularity: TVkDeviceSize;
    sparseAddressSpaceSize: TVkDeviceSize;
    maxBoundDescriptorSets: uint32_t;
    maxPerStageDescriptorSamplers: uint32_t;
    maxPerStageDescriptorUniformBuffers: uint32_t;
    maxPerStageDescriptorStorageBuffers: uint32_t;
    maxPerStageDescriptorSampledImages: uint32_t;
    maxPerStageDescriptorStorageImages: uint32_t;
    maxPerStageDescriptorInputAttachments: uint32_t;
    maxPerStageResources: uint32_t;
    maxDescriptorSetSamplers: uint32_t;
    maxDescriptorSetUniformBuffers: uint32_t;
    maxDescriptorSetUniformBuffersDynamic: uint32_t;
    maxDescriptorSetStorageBuffers: uint32_t;
    maxDescriptorSetStorageBuffersDynamic: uint32_t;
    maxDescriptorSetSampledImages: uint32_t;
    maxDescriptorSetStorageImages: uint32_t;
    maxDescriptorSetInputAttachments: uint32_t;
    maxVertexInputAttributes: uint32_t;
    maxVertexInputBindings: uint32_t;
    maxVertexInputAttributeOffset: uint32_t;
    maxVertexInputBindingStride: uint32_t;
    maxVertexOutputComponents: uint32_t;
    maxTessellationGenerationLevel: uint32_t;
    maxTessellationPatchSize: uint32_t;
    maxTessellationControlPerVertexInputComponents: uint32_t;
    maxTessellationControlPerVertexOutputComponents: uint32_t;
    maxTessellationControlPerPatchOutputComponents: uint32_t;
    maxTessellationControlTotalOutputComponents: uint32_t;
    maxTessellationEvaluationInputComponents: uint32_t;
    maxTessellationEvaluationOutputComponents: uint32_t;
    maxGeometryShaderInvocations: uint32_t;
    maxGeometryInputComponents: uint32_t;
    maxGeometryOutputComponents: uint32_t;
    maxGeometryOutputVertices: uint32_t;
    maxGeometryTotalOutputComponents: uint32_t;
    maxFragmentInputComponents: uint32_t;
    maxFragmentOutputAttachments: uint32_t;
    maxFragmentDualSrcAttachments: uint32_t;
    maxFragmentCombinedOutputResources: uint32_t;
    maxComputeSharedMemorySize: uint32_t;
    maxComputeWorkGroupCount: Array [0..2] of uint32_t;
    maxComputeWorkGroupInvocations: uint32_t;
    maxComputeWorkGroupSize: Array [0..2] of uint32_t;
    subPixelPrecisionBits: uint32_t;
    subTexelPrecisionBits: uint32_t;
    mipmapPrecisionBits: uint32_t;
    maxDrawIndexedIndexValue: uint32_t;
    maxDrawIndirectCount: uint32_t;
    maxSamplerLodBias: Single;
    maxSamplerAnisotropy: Single;
    maxViewports: uint32_t;
    maxViewportDimensions: Array [0..1] of uint32_t;
    viewportBoundsRange: Array [0..1] of Single;
    viewportSubPixelBits: uint32_t;
    minMemoryMapAlignment: size_t;
    minTexelBufferOffsetAlignment: TVkDeviceSize;
    minUniformBufferOffsetAlignment: TVkDeviceSize;
    minStorageBufferOffsetAlignment: TVkDeviceSize;
    minTexelOffset: int32_t;
    maxTexelOffset: uint32_t;
    minTexelGatherOffset: int32_t;
    maxTexelGatherOffset: uint32_t;
    minInterpolationOffset: Single;
    maxInterpolationOffset: Single;
    subPixelInterpolationOffsetBits: uint32_t;
    maxFramebufferWidth: uint32_t;
    maxFramebufferHeight: uint32_t;
    maxFramebufferLayers: uint32_t;
    framebufferColorSampleCounts: TVkSampleCountFlags;
    framebufferDepthSampleCounts: TVkSampleCountFlags;
    framebufferStencilSampleCounts: TVkSampleCountFlags;
    framebufferNoAttachmentsSampleCounts: TVkSampleCountFlags;
    maxColorAttachments: uint32_t;
    sampledImageColorSampleCounts: TVkSampleCountFlags;
    sampledImageIntegerSampleCounts: TVkSampleCountFlags;
    sampledImageDepthSampleCounts: TVkSampleCountFlags;
    sampledImageStencilSampleCounts: TVkSampleCountFlags;
    storageImageSampleCounts: TVkSampleCountFlags;
    maxSampleMaskWords: uint32_t;
    timestampComputeAndGraphics: TVkBool32;
    timestampPeriod: Single;
    maxClipDistances: uint32_t;
    maxCullDistances: uint32_t;
    maxCombinedClipAndCullDistances: uint32_t;
    discreteQueuePriorities: uint32_t;
    pointSizeRange: Array [0..1] of Single;
    lineWidthRange: Array [0..1] of Single;
    pointSizeGranularity: Single;
    lineWidthGranularity: Single;
    strictLines: TVkBool32;
    standardSampleLocations: TVkBool32;
    optimalBufferCopyOffsetAlignment: TVkDeviceSize;
    optimalBufferCopyRowPitchAlignment: TVkDeviceSize;
    nonCoherentAtomSize: TVkDeviceSize;
end;

  PVkPhysicalDeviceSparseProperties = ^TVkPhysicalDeviceSparseProperties;
  TVkPhysicalDeviceSparseProperties = record
    residencyStandard2DBlockShape: TVkBool32;
    residencyStandard2DMultisampleBlockShape: TVkBool32;
    residencyStandard3DBlockShape: TVkBool32;
    residencyAlignedMipSize: TVkBool32;
    residencyNonResidentStrict: TVkBool32;
  end;

  PVkPhysicalDeviceProperties = ^TVkPhysicalDeviceProperties;
  TVkPhysicalDeviceProperties = record
    apiVersion: uint32_t;
    driverVersion: uint32_t;
    vendorID: uint32_t;
    deviceID: uint32_t;
    deviceType: TVkPhysicalDeviceType;
    deviceName: Array [0..VK_MAX_PHYSICAL_DEVICE_NAME_SIZE-1] of AnsiChar;
    pipelineCacheUUID: Array [0..VK_UUID_SIZE-1]of uint8_t;
    limits: TVkPhysicalDeviceLimits;
    sparseProperties: TVkPhysicalDeviceSparseProperties;
  end;

  PVkQueueFamilyProperties = ^TVkQueueFamilyProperties;
  TVkQueueFamilyProperties = record
    queueFlags: TVkQueueFlags;
    queueCount: uint32_t;
    timestampValidBits: uint32_t;
    minImageTransferGranularity: TVkExtent3D;
  end;

  PVkMemoryType = ^TVkMemoryType;
  TVkMemoryType = record
    propertyFlags: TVkMemoryPropertyFlags;
    heapIndex: uint32_t;
  end;

  PVkMemoryHeap = ^TVkMemoryHeap;
  TVkMemoryHeap = record
    size: TVkDeviceSize;
    flags: TVkMemoryHeapFlags;
  end;

  PVkPhysicalDeviceMemoryProperties = ^TVkPhysicalDeviceMemoryProperties;
  TVkPhysicalDeviceMemoryProperties = record
    memoryTypeCount: uint32_t;
    memoryTypes: Array [0..VK_MAX_MEMORY_TYPES-1] of TVkMemoryType;
    memoryHeapCount: uint32_t;
    memoryHeaps: Array [0..VK_MAX_MEMORY_HEAPS-1] of TVkMemoryHeap;
  end;

  PVkDeviceQueueCreateInfo = ^TVkDeviceQueueCreateInfo;
  TVkDeviceQueueCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDeviceQueueCreateFlags;
    queueFamilyIndex: uint32_t;
    queueCount: uint32_t;
    pQueuePriorities: PSingle;
  end;

  PVkDeviceCreateInfo = ^TVkDeviceCreateInfo;
  TVkDeviceCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDeviceCreateFlags;
    queueCreateInfoCount: uint32_t;
    pQueueCreateInfos: PVkDeviceQueueCreateInfo;
    enabledLayerCount: uint32_t;
    ppEnabledLayerNames: PPAnsiChar;
    enabledExtensionCount: uint32_t;
    ppEnabledExtensionNames: PPAnsiChar;
    pEnabledFeatures: PVkPhysicalDeviceFeatures;
  end;

  PVkExtensionProperties = ^TVkExtensionProperties;
  TVkExtensionProperties = record
    extensionName: Array [0..VK_MAX_EXTENSION_NAME_SIZE-1] of AnsiChar;
    specVersion: uint32_t;
  end;

  PVkLayerProperties = ^TVkLayerProperties;
  TVkLayerProperties = record
    layerName: Array [0..VK_MAX_EXTENSION_NAME_SIZE-1] of AnsiChar;
    specVersion: uint32_t;
    implementationVersion: uint32_t;
    description: Array [0..VK_MAX_DESCRIPTION_SIZE-1] of AnsiChar;
  end;

  PVkSubmitInfo = ^TVkSubmitInfo;
  TVkSubmitInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    waitSemaphoreCount: uint32_t;
    pWaitSemaphores: PVkSemaphore;
    pWaitDstStageMask: PVkPipelineStageFlags;
    commandBufferCount: uint32_t;
    pCommandBuffers: PVkCommandBuffer;
    signalSemaphoreCount: uint32_t;
    pSignalSemaphores: PVkSemaphore;
  end;

  PVkMemoryAllocateInfo = ^TVkMemoryAllocateInfo;
  TVkMemoryAllocateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    allocationSize: TVkDeviceSize;
    memoryTypeIndex: uint32_t;
  end;

  PVkMappedMemoryRange = ^TVkMappedMemoryRange;
  TVkMappedMemoryRange = record
    sType: TVkStructureType;
    pNext: Pointer;
    memory: TVkDeviceMemory;
    offset: TVkDeviceSize;
    size: TVkDeviceSize;
  end;

  PVkMemoryRequirements = ^TVkMemoryRequirements;
  TVkMemoryRequirements = record
    size: TVkDeviceSize;
    alignment: TVkDeviceSize;
    memoryTypeBits: uint32_t;
  end;

  PVkSparseImageFormatProperties = ^TVkSparseImageFormatProperties;
  TVkSparseImageFormatProperties = record
    aspectMask: TVkImageAspectFlags;
    imageGranularity: TVkExtent3D;
    flags: TVkSparseImageFormatFlags;
  end;

  PVkSparseImageMemoryRequirements = ^TVkSparseImageMemoryRequirements;
  TVkSparseImageMemoryRequirements = record
    formatProperties: TVkSparseImageFormatProperties;
    imageMipTailFirstLod: uint32_t;
    imageMipTailSize: TVkDeviceSize;
    imageMipTailOffset: TVkDeviceSize;
    imageMipTailStride: TVkDeviceSize;
  end;

  PVkSparseMemoryBind = ^TVkSparseMemoryBind;
  TVkSparseMemoryBind = record
    resourceOffset: TVkDeviceSize;
    size: TVkDeviceSize;
    memory: TVkDeviceMemory;
    memoryOffset: TVkDeviceSize;
    flags: TVkSparseMemoryBindFlags;
  end;

  PVkSparseBufferMemoryBindInfo = ^TVkSparseBufferMemoryBindInfo;
  TVkSparseBufferMemoryBindInfo = record
    buffer: TVkBuffer;
    bindCount: uint32_t;
    pBinds: PVkSparseMemoryBind;
  end;

  PVkSparseImageOpaqueMemoryBindInfo = ^TVkSparseImageOpaqueMemoryBindInfo;
  TVkSparseImageOpaqueMemoryBindInfo = record
    image: TVkImage;
    bindCount: uint32_t;
    pBinds: PVkSparseMemoryBind;
  end;

  PVkImageSubresource = ^TVkImageSubresource;
  TVkImageSubresource = record
    aspectMask: TVkImageAspectFlags;
    mipLevel: uint32_t;
    arrayLayer: uint32_t;
  end;

  PVkOffset3D = ^TVkOffset3D;
  TVkOffset3D = record
    x: int32_t;
    y: int32_t;
    z: int32_t;
  end;

  PVkSparseImageMemoryBind = ^TVkSparseImageMemoryBind;
  TVkSparseImageMemoryBind = record
    subresource: TVkImageSubresource;
    offset: TVkOffset3D;
    extent: TVkExtent3D;
    memory: TVkDeviceMemory;
    memoryOffset: TVkDeviceSize;
    flags: TVkSparseMemoryBindFlags;
  end;

  PVkSparseImageMemoryBindInfo = ^TVkSparseImageMemoryBindInfo;
  TVkSparseImageMemoryBindInfo = record
    image: TVkImage;
    bindCount: uint32_t;
    pBinds: PVkSparseImageMemoryBind;
  end;

  PVkBindSparseInfo = ^TVkBindSparseInfo;
  TVkBindSparseInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    waitSemaphoreCount: uint32_t;
    pWaitSemaphores: PVkSemaphore;
    bufferBindCount: uint32_t;
    pBufferBinds: PVkSparseBufferMemoryBindInfo;
    imageOpaqueBindCount: uint32_t;
    pImageOpaqueBinds: PVkSparseImageOpaqueMemoryBindInfo;
    imageBindCount: uint32_t;
    pImageBinds: PVkSparseImageMemoryBindInfo;
    signalSemaphoreCount: uint32_t;
    pSignalSemaphores: PVkSemaphore;
  end;

  PVkFenceCreateInfo = ^TVkFenceCreateInfo;
  TVkFenceCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkFenceCreateFlags;
  end;

  PVkSemaphoreCreateInfo = ^TVkSemaphoreCreateInfo;
  TVkSemaphoreCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkSemaphoreCreateFlags;
  end;

  PVkEventCreateInfo = ^TVkEventCreateInfo;
  TVkEventCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkEventCreateFlags;
  end;

  PVkQueryPoolCreateInfo = ^TVkQueryPoolCreateInfo;
  TVkQueryPoolCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkQueryPoolCreateFlags;
    queryType: TVkQueryType;
    queryCount: uint32_t;
    pipelineStatistics: TVkQueryPipelineStatisticFlags;
  end;

  PVkBufferCreateInfo = ^TVkBufferCreateInfo;
  TVkBufferCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkBufferCreateFlags;
    size: TVkDeviceSize;
    usage: TVkBufferUsageFlags;
    sharingMode: TVkSharingMode;
    queueFamilyIndexCount: uint32_t;
    pQueueFamilyIndices: Puint32_t;
  end;

  PVkBufferViewCreateInfo = ^TVkBufferViewCreateInfo;
  TVkBufferViewCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkBufferViewCreateFlags;
    buffer: TVkBuffer;
    format: TVkFormat;
    offset: TVkDeviceSize;
    range: TVkDeviceSize;
  end;

  PVkImageCreateInfo = ^TVkImageCreateInfo;
  TVkImageCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkImageCreateFlags;
    imageType: TVkImageType;
    format: TVkFormat;
    extent: TVkExtent3D;
    mipLevels: uint32_t;
    arrayLayers: uint32_t;
    samples: TVkSampleCountFlagBits;
    tiling: TVkImageTiling;
    usage: TVkImageUsageFlags;
    sharingMode: TVkSharingMode;
    queueFamilyIndexCount: uint32_t;
    pQueueFamilyIndices: Puint32_t;
    initialLayout: TVkImageLayout;
  end;

  PVkSubresourceLayout = ^TVkSubresourceLayout;
  TVkSubresourceLayout = record
    offset: TVkDeviceSize;
    size: TVkDeviceSize;
    rowPitch: TVkDeviceSize;
    arrayPitch: TVkDeviceSize;
    depthPitch: TVkDeviceSize;
  end;

  PVkComponentMapping = ^TVkComponentMapping;
  TVkComponentMapping = record
    r: TVkComponentSwizzle;
    g: TVkComponentSwizzle;
    b: TVkComponentSwizzle;
    a: TVkComponentSwizzle;
  end;

  PVkImageSubresourceRange = ^TVkImageSubresourceRange;
  TVkImageSubresourceRange = record
    aspectMask: TVkImageAspectFlags;
    baseMipLevel: uint32_t;
    levelCount: uint32_t;
    baseArrayLayer: uint32_t;
    layerCount: uint32_t;
  end;

  PVkImageViewCreateInfo = ^TVkImageViewCreateInfo;
  TVkImageViewCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkImageViewCreateFlags;
    image: TVkImage;
    viewType: TVkImageViewType;
    format: TVkFormat;
    components: TVkComponentMapping;
    subresourceRange: TVkImageSubresourceRange;
  end;

  PVkShaderModuleCreateInfo = ^TVkShaderModuleCreateInfo;
  TVkShaderModuleCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkShaderModuleCreateFlags;
    codeSize: size_t;
    pCode: Puint32_t;
  end;

  PVkPipelineCacheCreateInfo = ^TVkPipelineCacheCreateInfo;
  TVkPipelineCacheCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineCacheCreateFlags;
    initialDataSize: size_t;
    pInitialData: Pointer;
  end;

  PVkSpecializationMapEntry = ^TVkSpecializationMapEntry;
  TVkSpecializationMapEntry = record
    constantID: uint32_t;
    offset: uint32_t;
    size: size_t;
  end;

  PVkSpecializationInfo = ^TVkSpecializationInfo;
  TVkSpecializationInfo = record
    mapEntryCount: uint32_t;
    pMapEntries: PVkSpecializationMapEntry;
    dataSize: size_t;
    pData: Pointer;
  end;

  PVkPipelineShaderStageCreateInfo = ^TVkPipelineShaderStageCreateInfo;
  TVkPipelineShaderStageCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineShaderStageCreateFlags;
    stage: TVkShaderStageFlagBits;
    module: TVkShaderModule;
    pName: PAnsiChar;
    pSpecializationInfo: PVkSpecializationInfo;
  end;

  PVkVertexInputBindingDescription = ^TVkVertexInputBindingDescription;
  TVkVertexInputBindingDescription = record
    binding: uint32_t;
    stride: uint32_t;
    inputRate: TVkVertexInputRate;
  end;

  PVkVertexInputAttributeDescription = ^TVkVertexInputAttributeDescription;
  TVkVertexInputAttributeDescription = record
    location: uint32_t;
    binding: uint32_t;
    format: TVkFormat;
    offset: uint32_t;
  end;

  PVkPipelineVertexInputStateCreateInfo = ^TVkPipelineVertexInputStateCreateInfo;
  TVkPipelineVertexInputStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineVertexInputStateCreateFlags;
    vertexBindingDescriptionCount: uint32_t;
    pVertexBindingDescriptions: PVkVertexInputBindingDescription;
    vertexAttributeDescriptionCount: uint32_t;
    pVertexAttributeDescriptions: PVkVertexInputAttributeDescription;
  end;

  PVkPipelineInputAssemblyStateCreateInfo = ^TVkPipelineInputAssemblyStateCreateInfo;
  TVkPipelineInputAssemblyStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineInputAssemblyStateCreateFlags;
    topology: TVkPrimitiveTopology;
    primitiveRestartEnable: TVkBool32;
  end;

  PVkPipelineTessellationStateCreateInfo = ^TVkPipelineTessellationStateCreateInfo;
  TVkPipelineTessellationStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineTessellationStateCreateFlags;
    patchControlPoints: uint32_t;
  end;

  PVkViewport = ^TVkViewport;
  TVkViewport = record
    x: Single;
    y: Single;
    width: Single;
    height: Single;
    minDepth: Single;
    maxDepth: Single;
  end;

  PVkOffset2D = ^TVkOffset2D;
  TVkOffset2D = record
    x: int32_t;
    y: int32_t;
  end;

  PVkExtent2D = ^TVkExtent2D;
  TVkExtent2D = record
    width: uint32_t;
    height: uint32_t;
  end;

  PVkRect2D = ^TVkRect2D;
  TVkRect2D = record
    offset: TVkOffset2D;
    extent: TVkExtent2D;
  end;

  PVkPipelineViewportStateCreateInfo = ^TVkPipelineViewportStateCreateInfo;
  TVkPipelineViewportStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineViewportStateCreateFlags;
    viewportCount: uint32_t;
    pViewports: PVkViewport;
    scissorCount: uint32_t;
    pScissors: PVkRect2D;
  end;

  PVkPipelineRasterizationStateCreateInfo = ^TVkPipelineRasterizationStateCreateInfo;
  TVkPipelineRasterizationStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineRasterizationStateCreateFlags;
    depthClampEnable: TVkBool32;
    rasterizerDiscardEnable: TVkBool32;
    polygonMode: TVkPolygonMode;
    cullMode: TVkCullModeFlags;
    frontFace: TVkFrontFace;
    depthBiasEnable: TVkBool32;
    depthBiasConstantFactor: Single;
    depthBiasClamp: Single;
    depthBiasSlopeFactor: Single;
    lineWidth: Single;
  end;

  PVkPipelineMultisampleStateCreateInfo = ^TVkPipelineMultisampleStateCreateInfo;
  TVkPipelineMultisampleStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineMultisampleStateCreateFlags;
    rasterizationSamples: TVkSampleCountFlagBits;
    sampleShadingEnable: TVkBool32;
    minSampleShading: Single;
    pSampleMask: PVkSampleMask;
    alphaToCoverageEnable: TVkBool32;
    alphaToOneEnable: TVkBool32;
  end;

  PVkStencilOpState = ^TVkStencilOpState;
  TVkStencilOpState = record
    failOp: TVkStencilOp;
    passOp: TVkStencilOp;
    depthFailOp: TVkStencilOp;
    compareOp: TVkCompareOp;
    compareMask: uint32_t;
    writeMask: uint32_t;
    reference: uint32_t;
  end;

  PVkPipelineDepthStencilStateCreateInfo = ^TVkPipelineDepthStencilStateCreateInfo;
  TVkPipelineDepthStencilStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineDepthStencilStateCreateFlags;
    depthTestEnable: TVkBool32;
    depthWriteEnable: TVkBool32;
    depthCompareOp: TVkCompareOp;
    depthBoundsTestEnable: TVkBool32;
    stencilTestEnable: TVkBool32;
    front: TVkStencilOpState;
    back: TVkStencilOpState;
    minDepthBounds: Single;
    maxDepthBounds: Single;
  end;

  PVkPipelineColorBlendAttachmentState = ^TVkPipelineColorBlendAttachmentState;
  TVkPipelineColorBlendAttachmentState = record
    blendEnable: TVkBool32;
    srcColorBlendFactor: TVkBlendFactor;
    dstColorBlendFactor: TVkBlendFactor;
    colorBlendOp: TVkBlendOp;
    srcAlphaBlendFactor: TVkBlendFactor;
    dstAlphaBlendFactor: TVkBlendFactor;
    alphaBlendOp: TVkBlendOp;
    colorWriteMask: TVkColorComponentFlags;
  end;

  PVkPipelineColorBlendStateCreateInfo = ^TVkPipelineColorBlendStateCreateInfo;
  TVkPipelineColorBlendStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineColorBlendStateCreateFlags;
    logicOpEnable: TVkBool32;
    logicOp: TVkLogicOp;
    attachmentCount: uint32_t;
    pAttachments: PVkPipelineColorBlendAttachmentState;
    blendConstants: Array [0..3] of Single;
  end;

  PVkPipelineDynamicStateCreateInfo = ^TVkPipelineDynamicStateCreateInfo;
  TVkPipelineDynamicStateCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineDynamicStateCreateFlags;
    dynamicStateCount: uint32_t;
    pDynamicStates: PVkDynamicState;
  end;

  PVkGraphicsPipelineCreateInfo = ^TVkGraphicsPipelineCreateInfo;
  TVkGraphicsPipelineCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineCreateFlags;
    stageCount: uint32_t;
    pStages: PVkPipelineShaderStageCreateInfo;
    pVertexInputState: PVkPipelineVertexInputStateCreateInfo;
    pInputAssemblyState: PVkPipelineInputAssemblyStateCreateInfo;
    pTessellationState: TVkPipelineTessellationStateCreateInfo;
    pViewportState: PVkPipelineViewportStateCreateInfo;
    pRasterizationState: PVkPipelineRasterizationStateCreateInfo;
    pMultisampleState: PVkPipelineMultisampleStateCreateInfo;
    pDepthStencilState: PVkPipelineDepthStencilStateCreateInfo;
    pColorBlendState: PVkPipelineColorBlendStateCreateInfo;
    pDynamicState: PVkPipelineDynamicStateCreateInfo;
    layout: TVkPipelineLayout;
    renderPass: TVkRenderPass;
    subpass: uint32_t;
    basePipelineHandle: TVkPipeline;
    basePipelineIndex: int32_t;
  end;

  PVkComputePipelineCreateInfo = ^TVkComputePipelineCreateInfo;
  TVkComputePipelineCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineCreateFlags;
    stage: TVkPipelineShaderStageCreateInfo;
    layout: TVkPipelineLayout;
    basePipelineHandle: TVkPipeline;
    basePipelineIndex: int32_t;
  end;

  PVkPushConstantRange = ^TVkPushConstantRange;
  TVkPushConstantRange = record
    stageFlags: TVkShaderStageFlags;
    offset: uint32_t;
    size: uint32_t;
  end;

  PVkPipelineLayoutCreateInfo = ^TVkPipelineLayoutCreateInfo;
  TVkPipelineLayoutCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkPipelineLayoutCreateFlags;
    setLayoutCount: uint32_t;
    pSetLayouts: PVkDescriptorSetLayout;
    pushConstantRangeCount: uint32_t;
    pPushConstantRanges: PVkPushConstantRange;
  end;

  PVkSamplerCreateInfo = ^TVkSamplerCreateInfo;
  TVkSamplerCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkSamplerCreateFlags;
    magFilter: TVkFilter;
    minFilter: TVkFilter;
    mipmapMode: TVkSamplerMipmapMode;
    addressModeU: TVkSamplerAddressMode;
    addressModeV: TVkSamplerAddressMode;
    addressModeW: TVkSamplerAddressMode;
    mipLodBias: Single;
    anisotropyEnable: TVkBool32;
    maxAnisotropy: Single;
    compareEnable: TVkBool32;
    compareOp: TVkCompareOp;
    minLod: Single;
    maxLod: Single;
    borderColor: TVkBorderColor;
    unnormalizedCoordinates: TVkBool32;
  end;

  PVkDescriptorSetLayoutBinding = ^TVkDescriptorSetLayoutBinding;
  TVkDescriptorSetLayoutBinding = record
    binding: uint32_t;
    descriptorType: TVkDescriptorType;
    descriptorCount: uint32_t;
    stageFlags: TVkShaderStageFlags;
    pImmutableSamplers: PVkSampler;
  end;

  PVkDescriptorSetLayoutCreateInfo = ^TVkDescriptorSetLayoutCreateInfo;
  TVkDescriptorSetLayoutCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDescriptorSetLayoutCreateFlags;
    bindingCount: uint32_t;
    pBindings: PVkDescriptorSetLayoutBinding;
  end;

  PVkDescriptorPoolSize = ^TVkDescriptorPoolSize;
  TVkDescriptorPoolSize = record
    type_: TVkDescriptorType;
    descriptorCount: uint32_t;
  end;

  PVkDescriptorPoolCreateInfo = ^TVkDescriptorPoolCreateInfo;
  TVkDescriptorPoolCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDescriptorPoolCreateFlags;
    maxSets: uint32_t;
    poolSizeCount: uint32_t;
    pPoolSizes: PVkDescriptorPoolSize;
  end;

  PVkDescriptorSetAllocateInfo = ^TVkDescriptorSetAllocateInfo;
  TVkDescriptorSetAllocateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    descriptorPool: TVkDescriptorPool;
    descriptorSetCount: uint32_t;
    pSetLayouts: PVkDescriptorSetLayout;
  end;

  PVkDescriptorImageInfo = ^TVkDescriptorImageInfo;
  TVkDescriptorImageInfo = record
    sampler: TVkSampler;
    imageView: TVkImageView;
    imageLayout: TVkImageLayout;
  end;

  PVkDescriptorBufferInfo = ^TVkDescriptorBufferInfo;
  TVkDescriptorBufferInfo = record
    buffer: TVkBuffer;
    offset: TVkDeviceSize;
    range: TVkDeviceSize;
  end;

  PVkWriteDescriptorSet = ^TVkWriteDescriptorSet;
  TVkWriteDescriptorSet = record
    sType: TVkStructureType;
    pNext: Pointer;
    dstSet: TVkDescriptorSet;
    dstBinding: uint32_t;
    dstArrayElement: uint32_t;
    descriptorCount: uint32_t;
    descriptorType: TVkDescriptorType;
    pImageInfo: PVkDescriptorImageInfo;
    pBufferInfo: PVkDescriptorBufferInfo;
    pTexelBufferView: PVkBufferView;
  end;

  PVkCopyDescriptorSet = ^TVkCopyDescriptorSet;
  TVkCopyDescriptorSet = record
    sType: TVkStructureType;
    pNext: Pointer;
    srcSet: TVkDescriptorSet;
    srcBinding: uint32_t;
    srcArrayElement: uint32_t;
    dstSet: TVkDescriptorSet;
    dstBinding: uint32_t;
    dstArrayElement: uint32_t;
    descriptorCount: uint32_t;
  end;

  PVkFramebufferCreateInfo = ^TVkFramebufferCreateInfo;
  TVkFramebufferCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkFramebufferCreateFlags;
    renderPass: TVkRenderPass;
    attachmentCount: uint32_t;
    pAttachments: PVkImageView;
    width: uint32_t;
    height: uint32_t;
    layers: uint32_t;
  end;

  PVkAttachmentDescription = ^TVkAttachmentDescription;
  TVkAttachmentDescription = record
    flags: TVkAttachmentDescriptionFlags;
    format: TVkFormat;
    samples: TVkSampleCountFlagBits;
    loadOp: TVkAttachmentLoadOp;
    storeOp: TVkAttachmentStoreOp;
    stencilLoadOp: TVkAttachmentLoadOp;
    stencilStoreOp: TVkAttachmentStoreOp;
    initialLayout: TVkImageLayout;
    finalLayout: TVkImageLayout;
  end;

  PVkAttachmentReference = ^TVkAttachmentReference;
  TVkAttachmentReference = record
    attachment: uint32_t;
    layout: TVkImageLayout;
  end;

  PVkSubpassDescription = ^TVkSubpassDescription;
  TVkSubpassDescription = record
    flags: TVkSubpassDescriptionFlags;
    pipelineBindPoint: TVkPipelineBindPoint;
    inputAttachmentCount: uint32_t;
    pInputAttachments: PVkAttachmentReference;
    colorAttachmentCount: uint32_t;
    pColorAttachments: PVkAttachmentReference;
    pResolveAttachments: PVkAttachmentReference;
    pDepthStencilAttachment: PVkAttachmentReference;
    preserveAttachmentCount: uint32_t;
    pPreserveAttachments: Puint32_t;
  end;

  PVkSubpassDependency = ^TVkSubpassDependency;
  TVkSubpassDependency = record
    srcSubpass: uint32_t;
    dstSubpass: uint32_t;
    srcStageMask: TVkPipelineStageFlags;
    dstStageMask: TVkPipelineStageFlags;
    srcAccessMask: TVkAccessFlags;
    dstAccessMask: TVkAccessFlags;
    dependencyFlags: TVkDependencyFlags;
  end;

  PVkRenderPassCreateInfo = ^TVkRenderPassCreateInfo;
  TVkRenderPassCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkRenderPassCreateFlags;
    attachmentCount: uint32_t;
    pAttachments: PVkAttachmentDescription;
    subpassCount: uint32_t;
    pSubpasses: PVkSubpassDescription;
    dependencyCount: uint32_t;
    pDependencies: PVkSubpassDependency;
  end;

  PVkCommandPoolCreateInfo = ^TVkCommandPoolCreateInfo;
  TVkCommandPoolCreateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkCommandPoolCreateFlags;
    queueFamilyIndex: uint32_t;
  end;

  PVkCommandBufferAllocateInfo = ^TVkCommandBufferAllocateInfo;
  TVkCommandBufferAllocateInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    commandPool: TVkCommandPool;
    level: TVkCommandBufferLevel;
    commandBufferCount: uint32_t;
  end;

  PVkCommandBufferInheritanceInfo = ^TVkCommandBufferInheritanceInfo;
  TVkCommandBufferInheritanceInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    renderPass: TVkRenderPass;
    subpass: uint32_t;
    framebuffer: TVkFramebuffer;
    occlusionQueryEnable: TVkBool32;
    queryFlags: TVkQueryControlFlags;
    pipelineStatistics: TVkQueryPipelineStatisticFlags;
  end;

  PVkCommandBufferBeginInfo = ^TVkCommandBufferBeginInfo;
  TVkCommandBufferBeginInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkCommandBufferUsageFlags;
    pInheritanceInfo: PVkCommandBufferInheritanceInfo;
  end;

  PVkBufferCopy = ^TVkBufferCopy;
  TVkBufferCopy = record
    srcOffset: TVkDeviceSize;
    dstOffset: TVkDeviceSize;
    size: TVkDeviceSize;
  end;

  PVkImageSubresourceLayers = ^TVkImageSubresourceLayers;
  TVkImageSubresourceLayers = record
    aspectMask: TVkImageAspectFlags;
    mipLevel: uint32_t;
    baseArrayLayer: uint32_t;
    layerCount: uint32_t;
  end;

  PVkImageCopy = ^TVkImageCopy;
  TVkImageCopy = record
    srcSubresource: TVkImageSubresourceLayers;
    srcOffset: TVkOffset3D;
    dstSubresource: TVkImageSubresourceLayers;
    dstOffset: TVkOffset3D;
    extent: TVkExtent3D;
  end;

  PVkImageBlit = ^TVkImageBlit;
  TVkImageBlit = record
    srcSubresource: TVkImageSubresourceLayers;
    srcOffsets: Array [0..1] of TVkOffset3D;
    dstSubresource: TVkImageSubresourceLayers;
    dstOffsets: Array [0..1] of TVkOffset3D;
  end;

  PVkBufferImageCopy = ^TVkBufferImageCopy;
  TVkBufferImageCopy = record
    bufferOffset: TVkDeviceSize;
    bufferRowLength: uint32_t;
    bufferImageHeight: uint32_t;
    imageSubresource: TVkImageSubresourceLayers;
    imageOffset: TVkOffset3D;
    imageExtent: TVkExtent3D;
  end;

  PVkClearColorValue = ^TVkClearColorValue;
  TVkClearColorValue = record
  case Byte of
    1: (float32: Array [0..3] of Single);
    2: (int32: Array [0..3] of int32_t);
    3: (uint32: Array [0..3] of uint32_t);
  end;

  PVkClearDepthStencilValue = ^TVkClearDepthStencilValue;
  TVkClearDepthStencilValue = record
    depth: Single;
    stencil: uint32_t;
  end;

  PVkClearValue = ^TVkClearValue;
  TVkClearValue = record
  case Byte of
    1: (color: TVkClearColorValue);
    2: (depthStencil: TVkClearDepthStencilValue);
  end;

  PVkClearAttachment = ^TVkClearAttachment;
  TVkClearAttachment = record
    aspectMask: TVkImageAspectFlags;
    colorAttachment: uint32_t;
    clearValue: TVkClearValue;
  end;

  PVkClearRect = ^TVkClearRect;
  TVkClearRect = record
    rect: TVkRect2D;
    baseArrayLayer: uint32_t;
    layerCount: uint32_t;
  end;

  PVkImageResolve = ^TVkImageResolve;
  TVkImageResolve = record
    srcSubresource: TVkImageSubresourceLayers;
    srcOffset: TVkOffset3D;
    dstSubresource: TVkImageSubresourceLayers;
    dstOffset: TVkOffset3D;
    extent: TVkExtent3D;
  end;

  PVkMemoryBarrier = ^TVkMemoryBarrier;
  TVkMemoryBarrier = record
    sType: TVkStructureType;
    pNext: Pointer;
    srcAccessMask: TVkAccessFlags;
    dstAccessMask: TVkAccessFlags;
  end;

  PVkBufferMemoryBarrier = ^TVkBufferMemoryBarrier;
  TVkBufferMemoryBarrier = record
    sType: TVkStructureType;
    pNext: Pointer;
    srcAccessMask: TVkAccessFlags;
    dstAccessMask: TvkAccessFlags;
    srcQueueFamilyIndex: uint32_t;
    dstQueueFamilyIndex: uint32_t;
    buffer: TVkBuffer;
    offset: TVkDeviceSize;
    size: TVkDeviceSize;
  end;

  PVkImageMemoryBarrier = ^TVkImageMemoryBarrier;
  TVkImageMemoryBarrier = record
    sType: TVkStructureType;
    pNext: Pointer;
    srcAccessMask: TVkAccessFlags;
    dstAccessMask: TVkAccessFlags;
    oldLayout: TVkImageLayout;
    newLayout: TVkImageLayout;
    srcQueueFamilyIndex: uint32_t;
    dstQueueFamilyIndex: uint32_t;
    image: TVkImage;
    subresourceRange: TVkImageSubresourceRange;
  end;

  PVkRenderPassBeginInfo = ^TVkRenderPassBeginInfo;
  TVkRenderPassBeginInfo = record
    sType: TVkStructureType;
    pNext: Pointer;
    renderPass: TVkRenderPass;
    framebuffer: TVkFramebuffer;
    renderArea: TVkRect2D;
    clearValueCount: uint32_t;
    pClearValues: PVkClearValue;
  end;

  PVkDispatchIndirectCommand = ^TVkDispatchIndirectCommand;
  TVkDispatchIndirectCommand = record
    x: uint32_t;
    y: uint32_t;
    z: uint32_t;
  end;

  PVkDrawIndexedIndirectCommand = ^TVkDrawIndexedIndirectCommand;
  TVkDrawIndexedIndirectCommand = record
    indexCount: uint32_t;
    instanceCount: uint32_t;
    firstIndex: uint32_t;
    vertexOffset: int32_t;
    firstInstance: uint32_t;
  end;

  PVkDrawIndirectCommand = ^TVkDrawIndirectCommand;
  TVkDrawIndirectCommand = record
    vertexCount: uint32_t;
    instanceCount: uint32_t;
    firstVertex: uint32_t;
    firstInstance: uint32_t;
  end;

  TvkCreateInstance = function (
                                const pCreateInfo: PVkInstanceCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pInstance: PVkInstance
                                ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyInstance = procedure (
                                instance: TVkInstance;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumeratePhysicalDevices = function (
                                instance: TVkInstance;
                                pPhysicalDeviceCount: Puint32_t;
                                pPhysicalDevices: PVkPhysicalDevice): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceFeatures = procedure (
                                physicalDevice: TVkPhysicalDevice;
                                pFeatures: PVkPhysicalDeviceFeatures); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceFormatProperties = procedure (
                                physicalDevice: TVkPhysicalDevice;
                                format: TVkFormat;
                                pFormatProperties: PVkFormatProperties); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceImageFormatProperties = function (
                                physicalDevice: TVkPhysicalDevice;
                                format: TVkFormat;
                                type_: TVkImageType;
                                tiling: TVkImageTiling;
                                usage: TVkImageUsageFlags;
                                flags: TVkImageCreateFlags;
                                pImageFormatProperties: PVkImageFormatProperties): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceProperties = procedure (
                                physicalDevice: TVkPhysicalDevice;
                                pProperties: PVkPhysicalDeviceProperties); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};


  TvkGetPhysicalDeviceQueueFamilyProperties = procedure(
                                physicalDevice: TVkPhysicalDevice;
                                pQueueFamilyPropertyCount: Puint32_t;
                                pQueueFamilyProperties: PVkQueueFamilyProperties); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceMemoryProperties = procedure (
                                physicalDevice: TVkPhysicalDevice;
                                pMemoryProperties: PVkPhysicalDeviceMemoryProperties); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetInstanceProcAddr = function (
                                instance: TVkInstance;
                                const pName: PAnsiChar): TvkVoidFunction; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceProcAddr = function (
                                instance: TVkInstance;
                                const pName: PAnsiChar): TvkVoidFunction; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDevice = function(
                                physicalDevice: TVkPhysicalDevice;
                                const pCreateInfo: PVkDeviceCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pDevice: PVkDevice): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDevice = procedure (
                                device: TVkDevice;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateInstanceExtensionProperties = function (
                                const pLayerName: PAnsiChar;
                                pPropertyCount: Puint32_t;
                                pProperties: PVkExtensionProperties): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateDeviceExtensionProperties = function (
                                physicalDevice: TVkPhysicalDevice;
                                const pLayerName: PAnsiChar;
                                pPropertyCount: Puint32_t;
                                pProperties: PVkExtensionProperties): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateInstanceLayerProperties = function (
                                pPropertyCount: Puint32_t;
                                pProperties: PVkLayerProperties): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEnumerateDeviceLayerProperties = function (
                                physicalDevice: TVkPhysicalDevice;
                                pPropertyCount: Puint32_t;
                                pProperties: PVkLayerProperties): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceQueue = procedure (
                                device: TVkDevice;
                                queueFamilyIndex: uint32_t;
                                queueIndex: uint32_t;
                                pQueue: PVkQueue); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueueSubmit = function (
                                queue: TVkQueue;
                                submitCount: uint32_t;
                                pSubmits: PVkSubmitInfo;
                                fence: TVkFence): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueueWaitIdle = function(
                                queue: TVkQueue): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDeviceWaitIdle = function (
                                device: TVkDevice): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAllocateMemory = function (
                                device: TVkDevice;
                                const pAllocateInfo: PVkMemoryAllocateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pMemory: PVkDeviceMemory): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFreeMemory = procedure (
                                device: TVkDevice;
                                memory: TVkDeviceMemory;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkMapMemory = function (
                                device: TVkDevice;
                                memory: TVkDeviceMemory;
                                offset: TVkDeviceSize;
                                size: TVkDeviceSize;
                                flags: TVkMemoryMapFlags;
                                ppData: PPointer): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkUnmapMemory = procedure (
                                vkUnmapMemory: TVkDevice;
                                memory: TVkDeviceMemory); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFlushMappedMemoryRanges = function (
                                device: TVkDevice;
                                memoryRangeCount: uint32_t;
                                const pMemoryRanges: PVkMappedMemoryRange): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkInvalidateMappedMemoryRanges = function (
                                device: TVkDevice;
                                memoryRangeCount: uint32_t;
                                const pMemoryRanges: PVkMappedMemoryRange): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDeviceMemoryCommitment = procedure (
                                device: TVkDevice;
                                memory: TVkDeviceMemory;
                                pCommittedMemoryInBytes: PVkDeviceSize); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkBindBufferMemory = function (
                                device: TVkDevice;
                                buffer: TVkBuffer;
                                memory: TVkDeviceMemory;
                                memoryOffset: TVkDeviceSize): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkBindImageMemory = function (
                                device: TVkDevice;
                                image: TVkImage;
                                memory: TVkDeviceMemory;
                                memoryOffset: TVkDeviceSize): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetBufferMemoryRequirements = procedure (
                                device: TVkDevice;
                                buffer: TVkBuffer;
                                pMemoryRequirements: PVkMemoryRequirements); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetImageMemoryRequirements = procedure (
                                device: TVkDevice;
                                image: TVkImage;
                                pMemoryRequirements: PVkMemoryRequirements); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetImageSparseMemoryRequirements = procedure (
                                device: TVkDevice;
                                image: TVkImage;
                                pSparseMemoryRequirementCount: Puint32_t;
                                pSparseMemoryRequirements: PVkSparseImageMemoryRequirements); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSparseImageFormatProperties = procedure (
                                physicalDevice: TVkPhysicalDevice;
                                format: TVkFormat;
                                type_: TVkImageType;
                                samples: TVkSampleCountFlagBits;
                                usage: TVkImageUsageFlags;
                                tiling: TVkImageTiling;
                                pPropertyCount: Puint32_t;
                                pProperties: PVkSparseImageFormatProperties); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueueBindSparse = function (
                                queue: TVkQueue;
                                bindInfoCount: uint32_t;
                                const pBindInfo: PVkBindSparseInfo;
                                fence: TVkFence): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateFence = function (
                                device: TVkDevice;
                                pCreateInfo: PVkFenceCreateInfo;
                                pAllocator: PVkAllocationCallbacks;
                                pFence: PVkFence): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyFence = procedure (
                                device: TVkDevice;
                                fence: TVkFence;
                                const pAllocator: TVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};


  TvkResetFences = function (
                                device: TVkDevice;
                                fenceCount: uint32_t;
                                pFences: PVkFence): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetFenceStatus = function (
                                device: TVkDevice;
                                fence: TVkFence): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkWaitForFences = function (
                                device: TVkDevice;
                                fenceCount: uint32_t;
                                const pFences: PVkFence;
                                waitAll: TVkBool32;
                                timeout: uint64_t): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateSemaphore = function (
                                device: TVkDevice;
                                pCreateInfo: PVkSemaphoreCreateInfo;
                                pAllocator: PVkAllocationCallbacks;
                                pSemaphore: PVkSemaphore): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};


  TvkDestroySemaphore = procedure (
                                device: TVkDevice;
                                semaphore: TVkSemaphore;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateEvent = function (
                                device: TVkDevice;
                                pCreateInfo: PVkEventCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pEvent: PVkEvent): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyEvent = procedure (
                                device: TVkDevice;
                                event: TVkEvent;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetEventStatus = function (
                                device: TVkDevice;
                                event: TVkEvent): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkSetEvent = function (
                                device: TVkDevice;
                                event: TVkEvent): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetEvent = function (
                                device: TVkDevice;
                                event: TVkEvent): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateQueryPool = function (
                                device: TVkDevice;
                                const pCreateInfo: PVkQueryPoolCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pQueryPool: PVkQueryPool): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyQueryPool = procedure (
                                device: TVkDevice;
                                queryPool: TVkQueryPool;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetQueryPoolResults = function (
                                device: TVkDevice;
                                queryPool: TVkQueryPool;
                                firstQuery: uint32_t;
                                queryCount: uint32_t;
                                dataSize: size_t;
                                pData: Pointer;
                                stride: TVkDeviceSize;
                                flags: TVkQueryResultFlags): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateBuffer = function (
                                device: TVkDevice;
                                const pCreateInfo: PVkBufferCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pBuffer: PVkBuffer): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyBuffer = procedure (
                                device: TVkDevice;
                                buffer: TVkBuffer;
                                pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateBufferView = function (
                                device: TVkDevice;
                                const pCreateInfo: PVkBufferViewCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pView: PVkBufferView): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyBufferView = procedure (
                                device: TVkDevice;
                                bufferView: TVkBufferView;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateImage = function (
                                device: TVkDevice;
                                pCreateInfo: PVkImageCreateInfo;
                                pAllocator: PVkAllocationCallbacks;
                                pImage: PVkImage): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyImage = procedure (
                                device: TVkDevice;
                                image: TVkImage;
                                pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetImageSubresourceLayout = procedure (
                                device: TVkDevice;
                                image: TVkImage;
                                const pSubresource: PVkImageSubresource;
                                pLayout: PVkSubresourceLayout); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateImageView = function (
                                device: TVkDevice;
                                const pCreateInfo: PVkImageViewCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pView: PVkImageView): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyImageView = procedure (
                                device: TVkDevice;
                                imageView: TVkImageView;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateShaderModule = function (
                                device: TVkDevice;
                                const pCreateInfo: PVkShaderModuleCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pShaderModule: PVkShaderModule): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyShaderModule = procedure (
                                device: TVkDevice;
                                shaderModule: TVkShaderModule;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreatePipelineCache = function (
                                device: TVkDevice;
                                pCreateInfo: PVkPipelineCacheCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pPipelineCache: PVkPipelineCache): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyPipelineCache = procedure (
                                device: TVkDevice;
                                pipelineCache: TVkPipelineCache;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPipelineCacheData = function (
                                device: TVkDevice;
                                pipelineCache: TVkPipelineCache;
                                pDataSize: Psize_t;
                                pData: Pointer): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkMergePipelineCaches = function (
                                device: TVkDevice;
                                dstCache: TVkPipelineCache;
                                srcCacheCount: uint32_t;
                                const pSrcCaches: PVkPipelineCache): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateGraphicsPipelines = function (
                                device: TVkDevice;
                                pipelineCache: TVkPipelineCache;
                                createInfoCount: uint32_t;
                                const pCreateInfos: PVkGraphicsPipelineCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pPipelines: PVkPipeline): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateComputePipelines = function (
                                device: TVkDevice;
                                pipelineCache: TVkPipelineCache;
                                createInfoCount: uint32_t;
                                const pCreateInfos: PVkComputePipelineCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pPipelines: PVkPipeline): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyPipeline = procedure (
                                device: TVkDevice;
                                pipeline: TVkPipeline;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreatePipelineLayout = function (
                                device: TVkDevice;
                                const pCreateInfo: PVkPipelineLayoutCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pPipelineLayout: PVkPipelineLayout): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyPipelineLayout = procedure (
                                device: TVkDevice;
                                pipelineLayout: TVkPipelineLayout;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateSampler = function (
                                device: TVkDevice;
                                pCreateInfo: PVkSamplerCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pSampler: PVkSampler): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroySampler = procedure (
                                device: TVkDevice;
                                sampler: TVkSampler;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDescriptorSetLayout = function (
                                device: TVkDevice;
                                const pCreateInfo: PVkDescriptorSetLayoutCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pSetLayout: PVkDescriptorSetLayout): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDescriptorSetLayout = procedure (
                                device: TVkDevice;
                                descriptorSetLayout: TVkDescriptorSetLayout;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDescriptorPool = function (
                                device: TVkDevice;
                                pCreateInfo: PVkDescriptorPoolCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pDescriptorPool: PVkDescriptorPool): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyDescriptorPool = procedure (
                                device: TVkDevice;
                                descriptorPool: TVkDescriptorPool;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetDescriptorPool = function (
                                device: TVkDevice;
                                descriptorPool: TVkDescriptorPool;
                                flags: TVkDescriptorPoolResetFlags): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAllocateDescriptorSets = function (
                                device: TVkDevice;
                                const pAllocateInfo: PVkDescriptorSetAllocateInfo;
                                pDescriptorSets: PVkDescriptorSet): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFreeDescriptorSets = function (
                                device: TVkDevice;
                                descriptorPool: TVkDescriptorPool;
                                descriptorSetCount: uint32_t;
                                const pDescriptorSets: PVkDescriptorSet): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkUpdateDescriptorSets = procedure (
                                device: TVkDevice;
                                descriptorWriteCount: uint32_t;
                                const pDescriptorWrites: PVkWriteDescriptorSet;
                                descriptorCopyCount: uint32_t;
                                const pDescriptorCopies: PVkCopyDescriptorSet); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateFramebuffer = function (
                                device: TVkDevice;
                                const pCreateInfo: PVkFramebufferCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pFramebuffer: PVkFramebuffer): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyFramebuffer = procedure (
                                device: TVkDevice;
                                framebuffer: TVkFramebuffer;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateRenderPass = function (
                                device: TVkDevice;
                                pCreateInfo: PVkRenderPassCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pRenderPass: PVkRenderPass): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyRenderPass = procedure (
                                device: TVkDevice;
                                renderPass: TVkRenderPass;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetRenderAreaGranularity = procedure (
                                device: TVkDevice;
                                renderPass: TVkRenderPass;
                                pGranularity: PVkExtent2D); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateCommandPool = function (
                                device: TVkDevice;
                                const pCreateInfo: PVkCommandPoolCreateInfo;
                                const pAllocator: PVkAllocationCallbacks;
                                pCommandPool: PVkCommandPool): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDestroyCommandPool = procedure (
                                device: TVkDevice;
                                commandPool: TVkCommandPool;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetCommandPool = function (
                                device: TVkDevice;
                                commandPool: TVkCommandPool;
                                flags: TVkCommandPoolResetFlags): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAllocateCommandBuffers = function (
                                device: TVkDevice;
                                pAllocateInfo: PVkCommandBufferAllocateInfo;
                                pCommandBuffers: PVkCommandBuffer): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkFreeCommandBuffers = procedure (
                                device: TVkDevice;
                                commandPool: TVkCommandPool;
                                commandBufferCount: uint32_t;
                                const pCommandBuffers: PVkCommandBuffer); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkBeginCommandBuffer = function (
                                commandBuffer: TVkCommandBuffer;
                                const pBeginInfo: PVkCommandBufferBeginInfo): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkEndCommandBuffer = function (
                                commandBuffer: TVkCommandBuffer): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkResetCommandBuffer = function (
                                commandBuffer: TVkCommandBuffer;
                                flags: TVkCommandBufferResetFlags): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindPipeline = procedure (
                                commandBuffer: TVkCommandBuffer;
                                pipelineBindPoint: TVkPipelineBindPoint;
                                pipeline: TVkPipeline); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetViewport = procedure (
                                commandBuffer: TVkCommandBuffer;
                                firstViewport: uint32_t;
                                viewportCount: uint32_t;
                                pViewports: PVkViewport); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetScissor = procedure (
                                commandBuffer: TVkCommandBuffer;
                                firstScissor: uint32_t;
                                scissorCount: uint32_t;
                                pScissors: PVkRect2D); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetLineWidth = procedure (
                                commandBuffer: TVkCommandBuffer;
                                lineWidth: Single); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetDepthBias = procedure (
                                commandBuffer: TVkCommandBuffer;
                                depthBiasConstantFactor: Single;
                                depthBiasClamp: Single;
                                depthBiasSlopeFactor: Single); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TVkBlendConstants_ = Array [0..3] of Single;
  TvkCmdSetBlendConstants = procedure (
                                commandBuffer: TVkCommandBuffer;
                                const blendConstants: TVkBlendConstants_); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetDepthBounds = procedure (
                                commandBuffer: TVkCommandBuffer;
                                minDepthBounds: Single;
                                maxDepthBounds: Single); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetStencilCompareMask = procedure (
                                commandBuffer: TVkCommandBuffer;
                                faceMask: TVkStencilFaceFlags;
                                compareMask: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetStencilWriteMask = procedure (
                                commandBuffer: TVkCommandBuffer;
                                faceMask: TVkStencilFaceFlags;
                                writeMask: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetStencilReference = procedure (
                                commandBuffer: TVkCommandBuffer;
                                faceMask: TVkStencilFaceFlags;
                                reference: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindDescriptorSets = procedure (
                                commandBuffer: TVkCommandBuffer;
                                pipelineBindPoint: TVkPipelineBindPoint;
                                layout: TVkPipelineLayout;
                                firstSet: uint32_t;
                                descriptorSetCount: uint32_t;
                                const pDescriptorSets: PVkDescriptorSet;
                                dynamicOffsetCount: uint32_t;
                                const pDynamicOffsets: Puint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindIndexBuffer = procedure (
                                commandBuffer: TVkCommandBuffer;
                                buffer: TVkBuffer;
                                offset: TVkDeviceSize;
                                indexType: TVkIndexType); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBindVertexBuffers = procedure (
                                commandBuffer: TVkCommandBuffer;
                                firstBinding: uint32_t;
                                bindingCount: uint32_t;
                                const pBuffers: PVkBuffer;
                                const pOffsets: PVkDeviceSize); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDraw = procedure (
                                commandBuffer: TVkCommandBuffer;
                                vertexCount: uint32_t;
                                instanceCount: uint32_t;
                                firstVertex: uint32_t;
                                firstInstance: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDrawIndexed = procedure (
                                commandBuffer: TVkCommandBuffer;
                                indexCount: uint32_t;
                                instanceCount: uint32_t;
                                firstIndex: uint32_t;
                                vertexOffset: int32_t;
                                firstInstance: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDrawIndirect = procedure (
                                commandBuffer: TVkCommandBuffer;
                                buffer: TVkBuffer;
                                offset: TVkDeviceSize;
                                drawCount: uint32_t;
                                stride: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDrawIndexedIndirect = procedure (
                                commandBuffer: TVkCommandBuffer;
                                buffer: TVkBuffer;
                                offset: TVkDeviceSize;
                                drawCount: uint32_t;
                                stride: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDispatch = procedure (
                                commandBuffer: TVkCommandBuffer;
                                x: uint32_t;
                                y: uint32_t;
                                z: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdDispatchIndirect = procedure (
                                commandBuffer: TVkCommandBuffer;
                                buffer: TVkBuffer;
                                offset: TVkDeviceSize); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyBuffer = procedure (
                                commandBuffer: TVkCommandBuffer;
                                srcBuffer: TVkBuffer;
                                dstBuffer: TVkBuffer;
                                regionCount: uint32_t;
                                const pRegions: PVkBufferCopy); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyImage = procedure (
                                commandBuffer: TVkCommandBuffer;
                                srcImage: TVkImage;
                                srcImageLayout: TVkImageLayout;
                                dstImage: TVkImage;
                                dstImageLayout: TVkImageLayout;
                                regionCount: uint32_t;
                                const pRegions: PVkImageCopy); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBlitImage = procedure (
                                commandBuffer: TVkCommandBuffer;
                                srcImage: TVkImage;
                                srcImageLayout: TVkImageLayout;
                                dstImage: TVkImage;
                                dstImageLayout: TVkImageLayout;
                                regionCount: uint32_t;
                                const pRegions: PVkImageCopy;
                                filter: TVkFilter); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyBufferToImage = procedure (
                                commandBuffer: TVkCommandBuffer;
                                srcBuffer: TVkBuffer;
                                dstImage: TVkImage;
                                dstImageLayout: TVkImageLayout;
                                regionCount: uint32_t;
                                const pRegions: PVkBufferImageCopy); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyImageToBuffer = procedure (
                                commandBuffer: TVkCommandBuffer;
                                srcImage: TVkImage;
                                srcImageLayout: TVkImageLayout;
                                dstBuffer: TVkBuffer;
                                regionCount: uint32_t;
                                const pRegions: PVkBufferImageCopy); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdUpdateBuffer = procedure (
                                commandBuffer: TVkCommandBuffer;
                                dstBuffer: TVkBuffer;
                                dstOffset: TVkDeviceSize;
                                dataSize: TVkDeviceSize;
                                const pData: Puint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdFillBuffer = procedure (
                                commandBuffer: TVkCommandBuffer;
                                dstBuffer: TVkBuffer;
                                dstOffset: TVkDeviceSize;
                                dataSize: TVkDeviceSize;
                                data: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdClearColorImage = procedure (
                                commandBuffer: TVkCommandBuffer;
                                image: TVkImage;
                                imageLayout: TVkImageLayout;
                                const pColor: PVkClearColorValue;
                                rangeCount: uint32_t;
                                const pRanges: PVkImageSubresourceRange); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdClearDepthStencilImage = procedure (
                                commandBuffer: TVkCommandBuffer;
                                image: TVkImage;
                                imageLayout: TVkImageLayout;
                                const pDepthStencil: PVkClearDepthStencilValue;
                                rangeCount: uint32_t;
                                const pRanges: PVkImageSubresourceRange); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdClearAttachments = procedure (
                                commandBuffer: TVkCommandBuffer;
                                attachmentCount: uint32_t;
                                const pAttachments: PVkClearAttachment;
                                rectCount: uint32_t;
                                const pRects: PVkClearRect); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdResolveImage = procedure (
                                commandBuffer: TVkCommandBuffer;
                                srcImage: TVkImage;
                                srcImageLayout: TVkImageLayout;
                                dstImage: TVkImage;
                                dstImageLayout: TVkImageLayout;
                                regionCount: uint32_t;
                                const pRegions: PVkImageResolve); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdSetEvent = procedure (
                                commandBuffer: TVkCommandBuffer;
                                event: TVkEvent;
                                stageMask: TVkPipelineStageFlags); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdResetEvent = procedure (
                                commandBuffer: TVkCommandBuffer;
                                event: TVkEvent;
                                stageMask: TVkPipelineStageFlags); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdWaitEvents = procedure (
                                commandBuffer: TVkCommandBuffer;
                                eventCount: uint32_t;
                                const pEvents: PVkEvent;
                                srcStageMask: TVkPipelineStageFlags;
                                dstStageMask: TVkPipelineStageFlags;
                                memoryBarrierCount: uint32_t;
                                const pMemoryBarriers: PVkMemoryBarrier;
                                bufferMemoryBarrierCount: uint32_t;
                                const pBufferMemoryBarriers: PVkBufferMemoryBarrier;
                                imageMemoryBarrierCount: uint32_t;
                                const pImageMemoryBarriers: PVkImageMemoryBarrier); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdPipelineBarrier = procedure (
                                commandBuffer: TVkCommandBuffer;
                                srcStageMask: TVkPipelineStageFlags;
                                dstStageMask: TVkPipelineStageFlags;
                                dependencyFlags: TVkDependencyFlags;
                                memoryBarrierCount: uint32_t;
                                const pMemoryBarriers: PVkMemoryBarrier;
                                bufferMemoryBarrierCount: uint32_t;
                                const pBufferMemoryBarriers: PVkBufferMemoryBarrier;
                                imageMemoryBarrierCount: uint32_t;
                                const pImageMemoryBarriers: PVkImageMemoryBarrier); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBeginQuery = procedure (
                                commandBuffer: TVkCommandBuffer;
                                queryPool: TVkQueryPool;
                                query: uint32_t;
                                flags: TVkQueryControlFlags); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdEndQuery = procedure (
                                commandBuffer: TVkCommandBuffer;
                                queryPool: TVkQueryPool;
                                query: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdResetQueryPool = procedure (
                                commandBuffer: TVkCommandBuffer;
                                queryPool: TVkQueryPool;
                                firstQuery: uint32_t;
                                queryCount: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdWriteTimestamp = procedure (
                                commandBuffer: TVkCommandBuffer;
                                pipelineStage: TVkPipelineStageFlagBits;
                                queryPool: TVkQueryPool;
                                query: uint32_t); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdCopyQueryPoolResults = procedure (
                                commandBuffer: TVkCommandBuffer;
                                queryPool: TVkQueryPool;
                                query: uint32_t;
                                firstQuery: uint32_t;
                                queryCount: uint32_t;
                                dstBuffer: TVkBuffer;
                                dstOffset: TVkDeviceSize;
                                stride: TVkDeviceSize;
                                flags: TVkQueryResultFlags); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdPushConstants = procedure (
                                commandBuffer: TVkCommandBuffer;
                                layout: TVkPipelineLayout;
                                stageFlags: TVkShaderStageFlags;
                                offset: uint32_t;
                                size: uint32_t;
                                const pValues: Pointer); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdBeginRenderPass = procedure (
                                commandBuffer: TVkCommandBuffer;
                                const pRenderPassBegin: PVkRenderPassBeginInfo;
                                contents: TVkSubpassContents); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdNextSubpass = procedure (
                                commandBuffer: TVkCommandBuffer;
                                contents: TVkSubpassContents); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdEndRenderPass = procedure (
                                commandBuffer: TVkCommandBuffer); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCmdExecuteCommands = procedure (
                                commandBuffer: TVkCommandBuffer;
                                commandBufferCount: uint32_t;
                                const pCommandBuffers: PVkCommandBuffer); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFNDEF VK_NO_PROTOTYPES}
var
  vkCreateInstance: TvkCreateInstance;
  vkDestroyInstance: TvkDestroyInstance;
  vkEnumeratePhysicalDevices: TvkEnumeratePhysicalDevices;
  vkGetPhysicalDeviceFeatures: TvkGetPhysicalDeviceFeatures;
  vkGetPhysicalDeviceFormatProperties: TvkGetPhysicalDeviceFormatProperties;
  vkGetPhysicalDeviceImageFormatProperties: TvkGetPhysicalDeviceImageFormatProperties;
  vkGetPhysicalDeviceProperties: TvkGetPhysicalDeviceProperties;
  vkGetPhysicalDeviceQueueFamilyProperties: TvkGetPhysicalDeviceQueueFamilyProperties;
  vkGetPhysicalDeviceMemoryProperties: TvkGetPhysicalDeviceMemoryProperties;
  vkGetInstanceProcAddr: TvkGetInstanceProcAddr;
  vkGetDeviceProcAddr: TvkGetDeviceProcAddr;
  vkCreateDevice: TvkCreateDevice;
  vkDestroyDevice: TvkDestroyDevice;
  vkEnumerateInstanceExtensionProperties: TvkEnumerateInstanceExtensionProperties;
  vkEnumerateDeviceExtensionProperties: TvkEnumerateDeviceExtensionProperties;
  vkEnumerateInstanceLayerProperties: TvkEnumerateInstanceLayerProperties;
  vkEnumerateDeviceLayerProperties: TvkEnumerateDeviceLayerProperties;
  vkGetDeviceQueue: TvkGetDeviceQueue;
  vkQueueSubmit: TvkQueueSubmit;
  vkQueueWaitIdle: TvkQueueWaitIdle;
  vkDeviceWaitIdle: TvkDeviceWaitIdle;
  vkAllocateMemory: TvkAllocateMemory;
  vkFreeMemory: TvkFreeMemory;
  vkMapMemory: TvkMapMemory;
  vkUnmapMemory: TvkUnmapMemory;
  vkFlushMappedMemoryRanges: TvkFlushMappedMemoryRanges;
  vkInvalidateMappedMemoryRanges: TvkInvalidateMappedMemoryRanges;
  vkGetDeviceMemoryCommitment: TvkGetDeviceMemoryCommitment;
  vkBindBufferMemory: TvkBindBufferMemory;
  vkBindImageMemory: TvkBindImageMemory;
  vkGetBufferMemoryRequirements: TvkGetBufferMemoryRequirements;
  vkGetImageMemoryRequirements: TvkGetImageMemoryRequirements;
  vkGetImageSparseMemoryRequirements: TvkGetImageSparseMemoryRequirements;
  vkGetPhysicalDeviceSparseImageFormatProperties: TvkGetPhysicalDeviceSparseImageFormatProperties;
  vkQueueBindSparse: TvkQueueBindSparse;
  vkCreateFence: TvkCreateFence;
  vkDestroyFence: TvkDestroyFence;
  vkResetFences: TvkResetFences;
  vkGetFenceStatus: TvkGetFenceStatus;
  vkWaitForFences: TvkWaitForFences;
  vkCreateSemaphore: TvkCreateSemaphore;
  vkDestroySemaphore: TvkDestroySemaphore;
  vkCreateEvent: TvkCreateEvent;
  vkDestroyEvent: TvkDestroyEvent;
  vkGetEventStatus: TvkGetEventStatus;
  vkSetEvent: TvkSetEvent;
  vkResetEvent: TvkResetEvent;
  vkCreateQueryPool: TvkCreateQueryPool;
  vkDestroyQueryPool: TvkDestroyQueryPool;
  vkGetQueryPoolResults: TvkGetQueryPoolResults;
  vkCreateBuffer: TvkCreateBuffer;
  vkDestroyBuffer: TvkDestroyBuffer;
  vkCreateBufferView: TvkCreateBufferView;
  vkDestroyBufferView: TvkDestroyBufferView;
  vkCreateImage: TvkCreateImage;
  vkDestroyImage: TvkDestroyImage;
  vkGetImageSubresourceLayout: TvkGetImageSubresourceLayout;
  vkCreateImageView: TvkCreateImageView;
  vkDestroyImageView: TvkDestroyImageView;
  vkCreateShaderModule: TvkCreateShaderModule;
  vkDestroyShaderModule: TvkDestroyShaderModule;
  vkCreatePipelineCache: TvkCreatePipelineCache;
  vkDestroyPipelineCache: TvkDestroyPipelineCache;
  vkGetPipelineCacheData: TvkGetPipelineCacheData;
  vkMergePipelineCaches: TvkMergePipelineCaches;
  vkCreateGraphicsPipelines: TvkCreateGraphicsPipelines;
  vkCreateComputePipelines: TvkCreateComputePipelines;
  vkDestroyPipeline: TvkDestroyPipeline;
  vkCreatePipelineLayout: TvkCreatePipelineLayout;
  vkDestroyPipelineLayout: TvkDestroyPipelineLayout;
  vkCreateSampler: TvkCreateSampler;
  vkDestroySampler: TvkDestroySampler;
  vkCreateDescriptorSetLayout: TvkCreateDescriptorSetLayout;
  vkDestroyDescriptorSetLayout: TvkDestroyDescriptorSetLayout;
  vkCreateDescriptorPool: TvkCreateDescriptorPool;
  vkDestroyDescriptorPool: TvkDestroyDescriptorPool;
  vkResetDescriptorPool: TvkResetDescriptorPool;
  vkAllocateDescriptorSets: TvkAllocateDescriptorSets;
  vkFreeDescriptorSets: TvkFreeDescriptorSets;
  vkUpdateDescriptorSets: TvkUpdateDescriptorSets;
  vkCreateFramebuffer: TvkCreateFramebuffer;
  vkDestroyFramebuffer: TvkDestroyFramebuffer;
  vkCreateRenderPass: TvkCreateRenderPass;
  vkDestroyRenderPass: TvkDestroyRenderPass;
  vkGetRenderAreaGranularity: TvkGetRenderAreaGranularity;
  vkCreateCommandPool: TvkCreateCommandPool;
  vkDestroyCommandPool: TvkDestroyCommandPool;
  vkResetCommandPool: TvkResetCommandPool;
  vkAllocateCommandBuffers: TvkAllocateCommandBuffers;
  vkFreeCommandBuffers: TvkFreeCommandBuffers;
  vkBeginCommandBuffer: TvkBeginCommandBuffer;
  vkEndCommandBuffer: TvkEndCommandBuffer;
  vkResetCommandBuffer: TvkResetCommandBuffer;
  vkCmdBindPipeline: TvkCmdBindPipeline;
  vkCmdSetViewport: TvkCmdSetViewport;
  vkCmdSetScissor: TvkCmdSetScissor;
  vkCmdSetLineWidth: TvkCmdSetLineWidth;
  vkCmdSetDepthBias: TvkCmdSetDepthBias;
  vkCmdSetBlendConstants: TvkCmdSetBlendConstants;
  vkCmdSetDepthBounds: TvkCmdSetDepthBounds;
  vkCmdSetStencilCompareMask: TvkCmdSetStencilCompareMask;
  vkCmdSetStencilWriteMask: TvkCmdSetStencilWriteMask;
  vkCmdSetStencilReference: TvkCmdSetStencilReference;
  vkCmdBindDescriptorSets: TvkCmdBindDescriptorSets;
  vkCmdBindIndexBuffer: TvkCmdBindIndexBuffer;
  vkCmdBindVertexBuffers: TvkCmdBindVertexBuffers;
  vkCmdDraw: TvkCmdDraw;
  vkCmdDrawIndexed: TvkCmdDrawIndexed;
  vkCmdDrawIndirect: TvkCmdDrawIndirect;
  vkCmdDrawIndexedIndirect: TvkCmdDrawIndexedIndirect;
  vkCmdDispatch: TvkCmdDispatch;
  vkCmdDispatchIndirect: TvkCmdDispatchIndirect;
  vkCmdCopyBuffer: TvkCmdCopyBuffer;
  vkCmdCopyImage: TvkCmdCopyImage;
  vkCmdBlitImage: TvkCmdBlitImage;
  vkCmdCopyBufferToImage: TvkCmdCopyBufferToImage;
  vkCmdCopyImageToBuffer: TvkCmdCopyImageToBuffer;
  vkCmdUpdateBuffer: TvkCmdUpdateBuffer;
  vkCmdFillBuffer: TvkCmdFillBuffer;
  vkCmdClearColorImage: TvkCmdClearColorImage;
  vkCmdClearDepthStencilImage: TvkCmdClearDepthStencilImage;
  vkCmdClearAttachments: TvkCmdClearAttachments;
  vkCmdResolveImage: TvkCmdResolveImage;
  vkCmdSetEvent: TvkCmdSetEvent;
  vkCmdResetEvent: TvkCmdResetEvent;
  vkCmdWaitEvents: TvkCmdWaitEvents;
  vkCmdPipelineBarrier: TvkCmdPipelineBarrier;
  vkCmdBeginQuery: TvkCmdBeginQuery;
  vkCmdEndQuery: TvkCmdEndQuery;
  vkCmdResetQueryPool: TvkCmdResetQueryPool;
  vkCmdWriteTimestamp: TvkCmdWriteTimestamp;
  vkCmdCopyQueryPoolResults: TvkCmdCopyQueryPoolResults;
  vkCmdPushConstants: TvkCmdPushConstants;
  vkCmdBeginRenderPass: TvkCmdBeginRenderPass;
  vkCmdNextSubpass: TvkCmdNextSubpass;
  vkCmdEndRenderPass: TvkCmdEndRenderPass;
  vkCmdExecuteCommands: TvkCmdExecuteCommands;
{$ENDIF}

const
  VK_KHR_surface = 1;

type
  PPVkSurfaceKHR = ^PVkSurfaceKHR;
  PVkSurfaceKHR = ^TVkSurfaceKHR;
  TVkSurfaceKHR = record
  end;

const
  VK_KHR_SURFACE_SPEC_VERSION       = 25;
  VK_KHR_SURFACE_EXTENSION_NAME: PAnsiChar = 'VK_KHR_surface';

type

  PVkColorSpaceKHR = ^TVkColorSpaceKHR;
  TVkColorSpaceKHR = (
    VK_COLORSPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLORSPACE_BEGIN_RANGE = VK_COLORSPACE_SRGB_NONLINEAR_KHR,
    VK_COLORSPACE_END_RANGE = VK_COLORSPACE_SRGB_NONLINEAR_KHR,
    VK_COLORSPACE_RANGE_SIZE = (VK_COLORSPACE_SRGB_NONLINEAR_KHR - VK_COLORSPACE_SRGB_NONLINEAR_KHR + 1),
    VK_COLORSPACE_MAX_ENUM = $7FFFFFFF
  );

  PVkPresentModeKHR = ^TVkPresentModeKHR;
  TVkPresentModeKHR = (
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_BEGIN_RANGE = VK_PRESENT_MODE_IMMEDIATE_KHR,
    VK_PRESENT_MODE_END_RANGE = VK_PRESENT_MODE_FIFO_RELAXED_KHR,
    VK_PRESENT_MODE_RANGE_SIZE = (VK_PRESENT_MODE_FIFO_RELAXED_KHR - VK_PRESENT_MODE_IMMEDIATE_KHR + 1),
    VK_PRESENT_MODE_MAX_ENUM = $7FFFFFFF
  );

  PVkSurfaceTransformFlagBitsKHR = ^TVkSurfaceTransformFlagBitsKHR;
  TVkSurfaceTransformFlagBitsKHR = (
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = $00000001,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = $00000002,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = $00000004,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = $00000008,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = $00000010,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = $00000020,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = $00000040,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = $00000080,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = $00000100
  );

  PVkSurfaceTransformFlagsKHR = ^TVkSurfaceTransformFlagsKHR;
  TVkSurfaceTransformFlagsKHR = TVkFlags;

  PVkCompositeAlphaFlagBitsKHR = ^TVkCompositeAlphaFlagBitsKHR;
  TVkCompositeAlphaFlagBitsKHR = (
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = $00000001,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = $00000002,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = $00000004,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = $00000008
  );

  PVkCompositeAlphaFlagsKHR = ^TVkCompositeAlphaFlagsKHR;
  TVkCompositeAlphaFlagsKHR = TVkFlags;

  PVkSurfaceCapabilitiesKHR = ^TVkSurfaceCapabilitiesKHR;
  TVkSurfaceCapabilitiesKHR = record
    minImageCount: uint32_t;
    maxImageCount: uint32_t;
    currentExtent: TVkExtent2D;
    minImageExtent: TVkExtent2D;
    maxImageExtent: TVkExtent2D;
    maxImageArrayLayers: uint32_t;
    supportedTransforms: TVkSurfaceTransformFlagsKHR;
    currentTransform: TVkSurfaceTransformFlagBitsKHR;
    supportedCompositeAlpha: TVkCompositeAlphaFlagsKHR;
    supportedUsageFlags: TVkImageUsageFlags;
  end;

  PVkSurfaceFormatKHR = ^TVkSurfaceFormatKHR;
  TVkSurfaceFormatKHR = record
    format: TVkFormat;
    colorSpace: TVkColorSpaceKHR;
  end;

  TvkDestroySurfaceKHR = procedure (
                                instance: TVkInstance;
                                surface: TVkSurfaceKHR;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfaceSupportKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                queueFamilyIndex: uint32_t;
                                surface: TVkSurfaceKHR;
                                pSupported: PVkBool32): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfaceCapabilitiesKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                surface: TVkSurfaceKHR;
                                pSurfaceCapabilities: PVkSurfaceCapabilitiesKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfaceFormatsKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                surface: TVkSurfaceKHR;
                                pSurfaceFormatCount: Puint32_t;
                                pSurfaceFormats: PVkSurfaceFormatKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceSurfacePresentModesKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                surface: TVkSurfaceKHR;
                                pPresentModeCount: Puint32_t;
                                pPresentModes: PVkPresentModeKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFNDEF VK_NO_PROTOTYPES}
var
  vkDestroySurfaceKHR: TvkDestroySurfaceKHR;
  vkGetPhysicalDeviceSurfaceSupportKHR: TvkGetPhysicalDeviceSurfaceSupportKHR;
  vkGetPhysicalDeviceSurfaceCapabilitiesKHR: TvkGetPhysicalDeviceSurfaceCapabilitiesKHR;
  vkGetPhysicalDeviceSurfaceFormatsKHR: TvkGetPhysicalDeviceSurfaceFormatsKHR;
  vkGetPhysicalDeviceSurfacePresentModesKHR: TvkGetPhysicalDeviceSurfacePresentModesKHR;
{$ENDIF}

const
  VK_KHR_swapchain = 1;

type
  PPVkSwapchainKHR = ^PVkSwapchainKHR;
  PVkSwapchainKHR = ^TVkSwapchainKHR;
  TVkSwapchainKHR = record
  end;

const
  VK_KHR_SWAPCHAIN_SPEC_VERSION     = 67;
  VK_KHR_SWAPCHAIN_EXTENSION_NAME: PAnsiChar = 'VK_KHR_swapchain';

type
  PVkSwapchainCreateFlagsKHR = ^TVkSwapchainCreateFlagsKHR;
  TVkSwapchainCreateFlagsKHR = TVkFlags;

  PVkSwapchainCreateInfoKHR = ^TVkSwapchainCreateInfoKHR;
  TVkSwapchainCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkSwapchainCreateFlagsKHR;
    surface: TVkSurfaceKHR;
    minImageCount: uint32_t;
    imageFormat: TVkFormat;
    imageColorSpace: TVkColorSpaceKHR;
    imageExtent: TVkExtent2D;
    imageArrayLayers: uint32_t;
    imageUsage: TVkImageUsageFlags;
    imageSharingMode: TVkSharingMode;
    queueFamilyIndexCount: uint32_t;
    pQueueFamilyIndices: Puint32_t;
    preTransform: TVkSurfaceTransformFlagBitsKHR;
    compositeAlpha: TVkCompositeAlphaFlagBitsKHR;
    presentMode: TVkPresentModeKHR;
    clipped: TVkBool32;
    oldSwapchain: TVkSwapchainKHR;
  end;

  PVkPresentInfoKHR = ^TVkPresentInfoKHR;
  TVkPresentInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    waitSemaphoreCount: uint32_t;
    pWaitSemaphores: PVkSemaphore;
    swapchainCount: uint32_t;
    pSwapchains: PVkSwapchainKHR;
    pImageIndices: Puint32_t;
    pResults: PVkResult;
  end;

  TvkCreateSwapchainKHR = function (
                                device: TVkDevice;
                                const pCreateInfo: PVkSwapchainCreateInfoKHR;
                                const pAllocator: PVkAllocationCallbacks;
                                pSwapchain: PVkSwapchainKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
  TvkDestroySwapchainKHR = procedure (
                                device: TVkDevice;
                                swapchain: TVkSwapchainKHR;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetSwapchainImagesKHR = function (
                                device: TVkDevice;
                                swapchain: TVkSwapchainKHR;
                                pSwapchainImageCount: Puint32_t;
                                pSwapchainImages: PVkImage): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkAcquireNextImageKHR = function (
                                device: TVkDevice;
                                swapchain: TVkSwapchainKHR;
                                timeout: uint64_t;
                                semaphore: TVkSemaphore;
                                fence: TVkFence;
                                pImageIndex: Puint32_t): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkQueuePresentKHR = function (
                                queue: TVkQueue;
                                const pPresentInfo: PVkPresentInfoKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFNDEF VK_NO_PROTOTYPES}
var
  vkCreateSwapchainKHR: TvkCreateSwapchainKHR;
  vkDestroySwapchainKHR: TvkDestroySwapchainKHR;
  vkGetSwapchainImagesKHR: TvkGetSwapchainImagesKHR;
  vkAcquireNextImageKHR: TvkAcquireNextImageKHR;
  vkQueuePresentKHR: TvkQueuePresentKHR;
{$ENDIF}

const
  VK_KHR_display = 1;

type
  PPVkDisplayKHR = ^PVkDisplayKHR;
  PVkDisplayKHR = ^TVkDisplayKHR;
  TVkDisplayKHR = record
  end;

  PPVkDisplayModeKHR = ^PVkDisplayModeKHR;
  PVkDisplayModeKHR = ^TVkDisplayModeKHR;
  TVkDisplayModeKHR = record
  end;

const
  VK_KHR_DISPLAY_SPEC_VERSION       = 21;
  VK_KHR_DISPLAY_EXTENSION_NAME: PAnsiChar = 'VK_KHR_display';


type

  PVkDisplayPlaneAlphaFlagBitsKHR = ^TVkDisplayPlaneAlphaFlagBitsKHR;
  TVkDisplayPlaneAlphaFlagBitsKHR = (
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = $00000001,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = $00000002,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = $00000004,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = $00000008
  );

  PVkDisplayModeCreateFlagsKHR = ^TVkDisplayModeCreateFlagsKHR;
  TVkDisplayModeCreateFlagsKHR = TVkFlags;

  PVkDisplayPlaneAlphaFlagsKHR = ^TVkDisplayPlaneAlphaFlagsKHR;
  TVkDisplayPlaneAlphaFlagsKHR = TVkFlags;

  PVkDisplaySurfaceCreateFlagsKHR = ^TVkDisplaySurfaceCreateFlagsKHR;
  TVkDisplaySurfaceCreateFlagsKHR = TVkFlags;

  PVkDisplayPropertiesKHR = ^TVkDisplayPropertiesKHR;
  TVkDisplayPropertiesKHR = record
    display: TVkDisplayKHR;
    displayName: PAnsiChar;
    physicalDimensions: TVkExtent2D;
    physicalResolution: TVkExtent2D;
    supportedTransforms: TVkSurfaceTransformFlagsKHR;
    planeReorderPossible: TVkBool32;
    persistentContent: TVkBool32;
  end;

  PVkDisplayModeParametersKHR = ^TVkDisplayModeParametersKHR;
  TVkDisplayModeParametersKHR = record
    visibleRegion: TVkExtent2D;
    refreshRate: uint32_t;
  end;

  PVkDisplayModePropertiesKHR = ^TVkDisplayModePropertiesKHR;
  TVkDisplayModePropertiesKHR = record
    displayMode: TVkDisplayModeKHR;
    parameters: TVkDisplayModeParametersKHR;
  end;

  PVkDisplayModeCreateInfoKHR = ^TVkDisplayModeCreateInfoKHR;
  TVkDisplayModeCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDisplayModeCreateFlagsKHR;
    parameters: TVkDisplayModeParametersKHR;
  end;

  PVkDisplayPlaneCapabilitiesKHR = ^TVkDisplayPlaneCapabilitiesKHR;
  TVkDisplayPlaneCapabilitiesKHR = record
    supportedAlpha: TVkDisplayPlaneAlphaFlagsKHR;
    minSrcPosition: TVkOffset2D;
    maxSrcPosition: TVkOffset2D;
    minSrcExtent: TVkExtent2D;
    maxSrcExtent: TVkExtent2D;
    minDstPosition: TVkOffset2D;
    maxDstPosition: TVkOffset2D;
    minDstExtent: TVkExtent2D;
    maxDstExtent: TVkExtent2D;
  end;

  PVkDisplayPlanePropertiesKHR = ^TVkDisplayPlanePropertiesKHR;
  TVkDisplayPlanePropertiesKHR = record
    currentDisplay: TVkDisplayKHR;
    currentStackIndex: uint32_t;
  end;

  PVkDisplaySurfaceCreateInfoKHR = ^TVkDisplaySurfaceCreateInfoKHR;
  TVkDisplaySurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDisplaySurfaceCreateFlagsKHR;
    displayMode: TVkDisplayModeKHR;
    planeIndex: uint32_t;
    planeStackIndex: uint32_t;
    transform: TVkSurfaceTransformFlagBitsKHR;
    globalAlpha: Single;
    alphaMode: TVkDisplayPlaneAlphaFlagBitsKHR;
    imageExtent: TVkExtent2D;
  end;

  TvkGetPhysicalDeviceDisplayPropertiesKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                pPropertyCount: Puint32_t;
                                pProperties: PVkDisplayPropertiesKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceDisplayPlanePropertiesKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                pPropertyCount: Puint32_t;
                                pProperties: PVkDisplayPlanePropertiesKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDisplayPlaneSupportedDisplaysKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                planeIndex: uint32_t;
                                pDisplayCount: Puint32_t;
                                pDisplays: PVkDisplayKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDisplayModePropertiesKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                display: TVkDisplayKHR;
                                pPropertyCount: Puint32_t;
                                pProperties: PVkDisplayModePropertiesKHR
                                ): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDisplayModeKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                display: TVkDisplayKHR;
                                const pCreateInfo: PVkDisplayModeCreateInfoKHR;
                                const pAllocator: PVkAllocationCallbacks;
                                pMode: PVkDisplayModeKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetDisplayPlaneCapabilitiesKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                mode: TVkDisplayModeKHR;
                                planeIndex: uint32_t;
                                pCapabilities: PVkDisplayPlaneCapabilitiesKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkCreateDisplayPlaneSurfaceKHR = function (
                                instance: TVkInstance;
                                const pCreateInfo: PVkDisplaySurfaceCreateInfoKHR;
                                const pAllocator: PVkAllocationCallbacks;
                                pSurface: PVkSurfaceKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFNDEF VK_NO_PROTOTYPES}
var
  vkGetPhysicalDeviceDisplayPropertiesKHR: TvkGetPhysicalDeviceDisplayPropertiesKHR;
  vkGetPhysicalDeviceDisplayPlanePropertiesKHR: TvkGetPhysicalDeviceDisplayPlanePropertiesKHR;
  vkGetDisplayPlaneSupportedDisplaysKHR: TvkGetDisplayPlaneSupportedDisplaysKHR;
  vkGetDisplayModePropertiesKHR: TvkGetDisplayModePropertiesKHR;
  vkCreateDisplayModeKHR: TvkCreateDisplayModeKHR;
  vkGetDisplayPlaneCapabilitiesKHR: TvkGetDisplayPlaneCapabilitiesKHR;
  vkCreateDisplayPlaneSurfaceKHR: TvkCreateDisplayPlaneSurfaceKHR;
{$ENDIF}

const
  VK_KHR_display_swapchain = 1;
  VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 9;
  VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME: PAnsiChar = 'VK_KHR_display_swapchain';


type

  PVkDisplayPresentInfoKHR = ^TVkDisplayPresentInfoKHR;
  TVkDisplayPresentInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    srcRect: TVkRect2D;
    dstRect: TVkRect2D;
    persistent: TVkBool32;
  end;

  TvkCreateSharedSwapchainsKHR = function (
                                device: TVkDevice;
                                swapchainCount: uint32_t;
                                const pCreateInfos: PVkSwapchainCreateInfoKHR;
                                const pAllocator: PVkAllocationCallbacks;
                                pSwapchains: PVkSwapchainKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFNDEF VK_NO_PROTOTYPES}
var
  vkCreateSharedSwapchainsKHR: TvkCreateSharedSwapchainsKHR;
{$ENDIF}

{$IFDEF VK_USE_PLATFORM_XLIB_KHR}
//#define VK_KHR_xlib_surface 1
//#include <X11/Xlib.h>

const
  VK_KHR_XLIB_SURFACE_SPEC_VERSION  = 6;
  VK_KHR_XLIB_SURFACE_EXTENSION_NAME: PAnsiChar = 'VK_KHR_xlib_surface';

type

  PVkXlibSurfaceCreateFlagsKHR = ^TVkXlibSurfaceCreateFlagsKHR;
  TVkXlibSurfaceCreateFlagsKHR = TVkFlags;

  PVkXlibSurfaceCreateInfoKHR = ^TVkXlibSurfaceCreateInfoKHR;
  TVkXlibSurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkXlibSurfaceCreateFlagsKHR;
    dpy: PDisplay;
    window: TWindow;
  end;


  TvkCreateXlibSurfaceKHR = function (
                                instance: TVkInstance;
                                const pCreateInfo: PVkXlibSurfaceCreateInfoKHR;
                                const pAllocator: PVkAllocationCallbacks;
                                pSurface: PVkSurfaceKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceXlibPresentationSupportKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                queueFamilyIndex: uint32_t;
                                dpy: PDisplay;
                                visualID: TVisualID): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFNDEF VK_NO_PROTOTYPES}
var
  vkCreateXlibSurfaceKHR: TvkCreateXlibSurfaceKHR;
  vkGetPhysicalDeviceXlibPresentationSupportKHR: TvkGetPhysicalDeviceXlibPresentationSupportKHR;
{$ENDIF}
{$ENDIF} //* VK_USE_PLATFORM_XLIB_KHR */

{$IFDEF VK_USE_PLATFORM_XCB_KHR}
//#define VK_KHR_xcb_surface 1
//#include <xcb/xcb.h>

const
  VK_KHR_XCB_SURFACE_SPEC_VERSION = 6;
  VK_KHR_XCB_SURFACE_EXTENSION_NAME: PAnsiChar = 'VK_KHR_xcb_surface';

type
  TVkXcbSurfaceCreateFlagsKHR = ^TVkXcbSurfaceCreateFlagsKHR;
  TVkXcbSurfaceCreateFlagsKHR = TVkFlags;

  PVkXcbSurfaceCreateInfoKHR = ^TVkXcbSurfaceCreateInfoKHR;
  TVkXcbSurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkXcbSurfaceCreateFlagsKHR;
    connection: Pxcb_connection_t;
    window: Txcb_window_t;
  end;


  TvkCreateXcbSurfaceKHR = function (
                                instance: TVkInstance;
                                const pCreateInfo: PVkXcbSurfaceCreateInfoKHR;
                                const pAllocator: PVkAllocationCallbacks;
                                pSurface: PVkSurfaceKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceXcbPresentationSupportKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                queueFamilyIndex: uint32_t;
                                connection: Pxcb_connection_t;
                                visual_id: xcb_visualid_t): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFDEF VK_NO_PROTOTYPES}
var
  vkCreateXcbSurfaceKHR: TvkCreateXcbSurfaceKHR;
  vkGetPhysicalDeviceXcbPresentationSupportKHR: TvkGetPhysicalDeviceXcbPresentationSupportKHR;
{$ENDIF}
{$ENDIF} //* VK_USE_PLATFORM_XCB_KHR */

{$IFDEF VK_USE_PLATFORM_WAYLAND_KHR}
const
  VK_KHR_wayland_surface = 1;
//#include <wayland-client.h>

const
  VK_KHR_WAYLAND_SURFACE_SPEC_VERSION = 5;
  VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME: PAnsiChar = 'VK_KHR_wayland_surface';

type
  PVkWaylandSurfaceCreateFlagsKHR = ^TVkWaylandSurfaceCreateFlagsKHR;
  TVkWaylandSurfaceCreateFlagsKHR = TVkFlags;

  PVkWaylandSurfaceCreateInfoKHR = ^TVkWaylandSurfaceCreateInfoKHR;
  TVkWaylandSurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkWaylandSurfaceCreateFlagsKHR;
    display: Pwl_display;
    surface: Pwl_surface;
  end;


  TvkCreateWaylandSurfaceKHR = function (
                                instance: TVkInstance;
                                const pCreateInfo: PVkWaylandSurfaceCreateInfoKHR;
                                const pAllocator: PVkAllocationCallbacks;
                                pSurface: PVkSurfaceKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceWaylandPresentationSupportKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                queueFamilyIndex: uint32_t;
                                display: Pwl_display): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFNDEF VK_NO_PROTOTYPES}
var
  vkCreateWaylandSurfaceKHR: TvkCreateWaylandSurfaceKHR;
  vkGetPhysicalDeviceWaylandPresentationSupportKHR: TvkGetPhysicalDeviceWaylandPresentationSupportKHR;
{$ENDIF}
{$ENDIF} //* VK_USE_PLATFORM_WAYLAND_KHR */

{$IFDEF VK_USE_PLATFORM_MIR_KHR}
const
  VK_KHR_mir_surface = 1;
//#include <mir_toolkit/client_types.h>

const
  VK_KHR_MIR_SURFACE_SPEC_VERSION   = 4;
  VK_KHR_MIR_SURFACE_EXTENSION_NAME: PAnsiChar = 'VK_KHR_mir_surface';

type
  PVkMirSurfaceCreateFlagsKHR = ^TVkMirSurfaceCreateFlagsKHR;
  TVkMirSurfaceCreateFlagsKHR = TVkFlags;

  PVkMirSurfaceCreateInfoKHR = ^TVkMirSurfaceCreateInfoKHR;
  TVkMirSurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkMirSurfaceCreateFlagsKHR;
    connection: PMirConnection;
    mirSurface: PMirSurface;
  end;


  TvkCreateMirSurfaceKHR = function (
                                instance: TVkInstance;
                                const pCreateInfo: PVkMirSurfaceCreateInfoKHR;
                                const pAllocator: PVkAllocationCallbacks;
                                pSurface: PVkSurfaceKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceMirPresentationSupportKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                queueFamilyIndex: uint32_t;
                                connection: PMirConnection): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFNDEF VK_NO_PROTOTYPES}
var
  vkCreateMirSurfaceKHR: TvkCreateMirSurfaceKHR;
  vkGetPhysicalDeviceMirPresentationSupportKHR: TvkGetPhysicalDeviceMirPresentationSupportKHR;
{$ENDIF}
{$ENDIF} //* VK_USE_PLATFORM_MIR_KHR */

{$IFDEF VK_USE_PLATFORM_ANDROID_KHR}
const
  VK_KHR_android_surface = 1;
//#include <android/native_window.h>

const
  VK_KHR_ANDROID_SURFACE_SPEC_VERSION = 6;
  VK_KHR_ANDROID_SURFACE_EXTENSION_NAME: PAnsiChar = 'VK_KHR_android_surface';

type
  PVkAndroidSurfaceCreateFlagsKHR = ^TVkAndroidSurfaceCreateFlagsKHR;
  TVkAndroidSurfaceCreateFlagsKHR = TVkFlags;

  PVkAndroidSurfaceCreateInfoKHR = ^TVkAndroidSurfaceCreateInfoKHR;
  TVkAndroidSurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkAndroidSurfaceCreateFlagsKHR;
    window: PANativeWindow;
  end;


  TvkCreateAndroidSurfaceKHR = function (
                                instance: TVkInstance;
                                const pCreateInfo: PVkAndroidSurfaceCreateInfoKHR;
                                const pAllocator: PVkAllocationCallbacks;
                                pSurface: PVkSurfaceKHR): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFNDEF VK_NO_PROTOTYPES}
var
  vkCreateAndroidSurfaceKHR: TvkCreateAndroidSurfaceKHR;
{$ENDIF}
{$ENDIF} //* VK_USE_PLATFORM_ANDROID_KHR */

{$IFDEF VK_USE_PLATFORM_WIN32_KHR}
//#define VK_KHR_win32_surface 1
//#include <windows.h>

const
  VK_KHR_WIN32_SURFACE_SPEC_VERSION = 5;
  VK_KHR_WIN32_SURFACE_EXTENSION_NAME: PAnsiChar = 'VK_KHR_win32_surface';

type

  PVkWin32SurfaceCreateFlagsKHR = ^TVkWin32SurfaceCreateFlagsKHR;
  TVkWin32SurfaceCreateFlagsKHR = TVkFlags;

  PVkWin32SurfaceCreateInfoKHR = ^TVkWin32SurfaceCreateInfoKHR;
  TVkWin32SurfaceCreateInfoKHR = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkWin32SurfaceCreateFlagsKHR;
    hinstance: HINST;
    hwnd: HWND;
  end;

  TvkCreateWin32SurfaceKHR = function (
                                instance: TVkInstance;
                                const pCreateInfo: PVkWin32SurfaceCreateInfoKHR;
                                const pAllocator: PVkAllocationCallbacks;
                                pSurface: PVkSurfaceKHR): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkGetPhysicalDeviceWin32PresentationSupportKHR = function (
                                physicalDevice: TVkPhysicalDevice;
                                queueFamilyIndex: uint32_t): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFNDEF VK_NO_PROTOTYPES}
var
  vkCreateWin32SurfaceKHR: TvkCreateWin32SurfaceKHR;
  vkGetPhysicalDeviceWin32PresentationSupportKHR: TvkGetPhysicalDeviceWin32PresentationSupportKHR;
{$ENDIF}
{$ENDIF} //* VK_USE_PLATFORM_WIN32_KHR */

const
  VK_EXT_debug_report = 1;

type
  PPVkDebugReportCallbackEXT = ^PVkDebugReportCallbackEXT;
  PVkDebugReportCallbackEXT = ^TVkDebugReportCallbackEXT;
  TVkDebugReportCallbackEXT = record
  end;

const
  VK_EXT_DEBUG_REPORT_SPEC_VERSION  = 1;
  VK_EXT_DEBUG_REPORT_EXTENSION_NAME: PAnsiChar = 'VK_EXT_debug_report';

type
  PVkDebugReportObjectTypeEXT = ^TVkDebugReportObjectTypeEXT;
  TVkDebugReportObjectTypeEXT = (
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28
  );

  PVkDebugReportErrorEXT = ^TVkDebugReportErrorEXT;
  TVkDebugReportErrorEXT = (
    VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
    VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1
  );

  PVkDebugReportFlagBitsEXT = ^TVkDebugReportFlagBitsEXT;
  TVkDebugReportFlagBitsEXT = (
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = $00000001,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = $00000002,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = $00000004,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = $00000008,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = $00000010
  );

  PVkDebugReportFlagsEXT = ^TVkDebugReportFlagsEXT;
  TVkDebugReportFlagsEXT = TVkFlags;

  TvkDebugReportCallback_f_EXT = function (
                                flags: TVkDebugReportFlagsEXT;
                                objectType: TVkDebugReportObjectTypeEXT;
                                object_: uint64_t;
                                location: size_t;
                                messageCode: int32_t;
                                pLayerPrefix: PAnsiChar;
                                pMessage: PAnsiChar;
                                pUserData: Pointer): TVkBool32; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  PVkDebugReportCallbackCreateInfoEXT = ^TVkDebugReportCallbackCreateInfoEXT;
  TVkDebugReportCallbackCreateInfoEXT = record
    sType: TVkStructureType;
    pNext: Pointer;
    flags: TVkDebugReportFlagsEXT;
    pfnCallback: TvkDebugReportCallbackEXT;
    pUserData: Pointer;
  end;


  TvkCreateDebugReportCallbackEXT = function (
                                instance: TVkInstance;
                                const pCreateInfo: PVkDebugReportCallbackCreateInfoEXT;
                                const pAllocator: PVkAllocationCallbacks;
                                pCallback: PVkDebugReportCallbackEXT): TVkResult; {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};
  TvkDestroyDebugReportCallbackEXT = procedure (
                                instance: TVkInstance;
                                callback: TVkDebugReportCallbackEXT;
                                const pAllocator: PVkAllocationCallbacks); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

  TvkDebugReportMessageEXT = procedure (
                                instance: TVkInstance;
                                flags: TVkDebugReportFlagsEXT;
                                objectType: TVkDebugReportObjectTypeEXT;
                                object_: uint64_t;
                                location: size_t;
                                messageCode: int32_t;
                                pLayerPrefix: PAnsiChar;
                                pMessage: PAnsiChar); {$IFDEF CDECL}cdecl{$ELSE}stdcall{$ENDIF};

{$IFNDEF VK_NO_PROTOTYPES}
var
  vkCreateDebugReportCallbackEXT: TvkCreateDebugReportCallbackEXT;
  vkDestroyDebugReportCallbackEXT: TvkDestroyDebugReportCallbackEXT;
  vkDebugReportMessageEXT: TvkDebugReportMessageEXT;
{$ENDIF}


function vulkanGetProcAddress(ProcName: PAnsiChar; LibHandle: Pointer = nil): Pointer;
function InitVulkan(LibName: String = VulkanLibName): Boolean;

{$IFNDEF VK_NO_PROTOTYPES}
var
  Vulkan_LibHandle: Pointer = nil;
{$ENDIF}

implementation

function VK_MAKE_VERSION(const major, minor, patch: Integer): Integer;
begin
  Result := (((major) shl 22) or ((minor) shl 12) or (patch));
end;

function VK_API_VERSION(): Integer;
begin
  Result := VK_MAKE_VERSION(1, 0, 3);
end;

function VK_VERSION_MAJOR(version: Cardinal): Integer;
begin
  Result := version shr 22;
end;

function VK_VERSION_MINOR(version: Cardinal): Integer;
begin
  Result := ((version shr 12) and $3ff);
end;

function VK_VERSION_PATCH(version: Cardinal): Integer;
begin
  Result := (version and $fff);
end;

{$IFDEF LINUX}
const
  RTLD_LAZY = $001;
  RTLD_NOW = $002;
  RTLD_BINDING_MASK = $003;

  // Seems to work on Debian / Fedora
  LibraryLib = {$IFDEF LINUX} 'libdl.so.2'{$ELSE} 'c'{$ENDIF};

function dlopen(Name: PAnsiChar; Flags: LongInt): Pointer; cdecl; external LibraryLib name 'dlopen';
function dlclose(Lib: Pointer): LongInt; cdecl; external LibraryLib name 'dlclose';
function dlsym(Lib: Pointer; Name: PAnsiChar): Pointer; cdecl; external LibraryLib name 'dlsym';
{$ENDIF}

function vulkanLoadLibrary(Name: PChar): Pointer;
begin
  {$IFDEF WINDOWS}
    Result := Pointer(LoadLibrary(Name));
  {$ENDIF}

  {$IFDEF LINUX}
    Result := dlopen(Name, RTLD_LAZY);
  {$ENDIF}
end;

function vulkanFreeLibrary(LibHandle: Pointer): Boolean;
begin
  if LibHandle = nil then
    Result := False
  else
  {$IFDEF WINDOWS}
    Result := FreeLibrary(HMODULE(LibHandle));
  {$ENDIF}

  {$IFDEF LINUX}
    Result := dlclose(LibHandle) = 0;
  {$ENDIF}
end;

function vulkanGetProcAddress(ProcName: PAnsiChar; LibHandle: Pointer = nil): Pointer;
begin
  if LibHandle = nil then LibHandle := Vulkan_LibHandle;

  {$IFDEF WINDOWS}
    Result := GetProcAddress(HMODULE(LibHandle), ProcName);
  {$ENDIF}

  {$IFDEF LINUX}
    Result := dlsym(LibHandle, ProcName);
  {$ENDIF}
end;
function InitVulkan(LibName: String = VulkanLibName): Boolean;
begin
  Result := False;

  // free opened libraries
  if Vulkan_LibHandle <> nil then
    vulkanFreeLibrary(Vulkan_LibHandle);

  // load library
  Vulkan_LibHandle := vulkanLoadLibrary(PChar(LibName));

  // load CL functions
  if (Vulkan_LibHandle <> nil) then
  begin
    //I think need rewrite https://www.khronos.org/registry/vulkan/specs/1.0/man/html/vkGetInstanceProcAddr.html
    vkCreateInstance := TvkCreateInstance(vulkanGetProcAddress('vkCreateInstance', Vulkan_LibHandle));
    vkDestroyInstance := TvkDestroyInstance(vulkanGetProcAddress('vkDestroyInstance', Vulkan_LibHandle));
    vkEnumeratePhysicalDevices := TvkEnumeratePhysicalDevices(vulkanGetProcAddress('vkEnumeratePhysicalDevices', Vulkan_LibHandle));
    vkGetPhysicalDeviceFeatures := TvkGetPhysicalDeviceFeatures(vulkanGetProcAddress('vkGetPhysicalDeviceFeatures', Vulkan_LibHandle));
    vkGetPhysicalDeviceFormatProperties := TvkGetPhysicalDeviceFormatProperties(vulkanGetProcAddress('vkGetPhysicalDeviceFormatProperties', Vulkan_LibHandle));
    vkGetPhysicalDeviceImageFormatProperties := TvkGetPhysicalDeviceImageFormatProperties(vulkanGetProcAddress('vkGetPhysicalDeviceImageFormatProperties', Vulkan_LibHandle));
    vkGetPhysicalDeviceProperties := TvkGetPhysicalDeviceProperties(vulkanGetProcAddress('vkGetPhysicalDeviceProperties', Vulkan_LibHandle));
    vkGetPhysicalDeviceQueueFamilyProperties := TvkGetPhysicalDeviceQueueFamilyProperties(vulkanGetProcAddress('vkGetPhysicalDeviceQueueFamilyProperties', Vulkan_LibHandle));
    vkGetPhysicalDeviceMemoryProperties := TvkGetPhysicalDeviceMemoryProperties(vulkanGetProcAddress('vkGetPhysicalDeviceMemoryProperties', Vulkan_LibHandle));
    vkGetInstanceProcAddr := TvkGetInstanceProcAddr(vulkanGetProcAddress('vkGetInstanceProcAddr', Vulkan_LibHandle));
    vkGetDeviceProcAddr := TvkGetDeviceProcAddr(vulkanGetProcAddress('vkGetDeviceProcAddr', Vulkan_LibHandle));
    vkCreateDevice := TvkCreateDevice(vulkanGetProcAddress('vkCreateDevice', Vulkan_LibHandle));
    vkDestroyDevice := TvkDestroyDevice(vulkanGetProcAddress('vkDestroyDevice', Vulkan_LibHandle));
    vkEnumerateInstanceExtensionProperties := TvkEnumerateInstanceExtensionProperties(vulkanGetProcAddress('vkEnumerateInstanceExtensionProperties', Vulkan_LibHandle));
    vkEnumerateDeviceExtensionProperties := TvkEnumerateDeviceExtensionProperties(vulkanGetProcAddress('vkEnumerateDeviceExtensionProperties', Vulkan_LibHandle));
    vkEnumerateInstanceLayerProperties := TvkEnumerateInstanceLayerProperties(vulkanGetProcAddress('vkEnumerateInstanceLayerProperties', Vulkan_LibHandle));
    vkEnumerateDeviceLayerProperties := TvkEnumerateDeviceLayerProperties(vulkanGetProcAddress('vkEnumerateDeviceLayerProperties', Vulkan_LibHandle));
    vkGetDeviceQueue := TvkGetDeviceQueue(vulkanGetProcAddress('vkGetDeviceQueue', Vulkan_LibHandle));
    vkQueueSubmit := TvkQueueSubmit(vulkanGetProcAddress('vkQueueSubmit', Vulkan_LibHandle));
    vkQueueWaitIdle := TvkQueueWaitIdle(vulkanGetProcAddress('vkQueueWaitIdle', Vulkan_LibHandle));
    vkDeviceWaitIdle := TvkDeviceWaitIdle(vulkanGetProcAddress('vkDeviceWaitIdle', Vulkan_LibHandle));
    vkAllocateMemory := TvkAllocateMemory(vulkanGetProcAddress('vkAllocateMemory', Vulkan_LibHandle));
    vkFreeMemory := TvkFreeMemory(vulkanGetProcAddress('vkFreeMemory', Vulkan_LibHandle));
    vkMapMemory := TvkMapMemory(vulkanGetProcAddress('vkMapMemory', Vulkan_LibHandle));
    vkUnmapMemory := TvkUnmapMemory(vulkanGetProcAddress('vkUnmapMemory', Vulkan_LibHandle));
    vkFlushMappedMemoryRanges := TvkFlushMappedMemoryRanges(vulkanGetProcAddress('vkFlushMappedMemoryRanges', Vulkan_LibHandle));
    vkInvalidateMappedMemoryRanges := TvkInvalidateMappedMemoryRanges(vulkanGetProcAddress('vkInvalidateMappedMemoryRanges', Vulkan_LibHandle));
    vkGetDeviceMemoryCommitment := TvkGetDeviceMemoryCommitment(vulkanGetProcAddress('vkGetDeviceMemoryCommitment', Vulkan_LibHandle));
    vkBindBufferMemory := TvkBindBufferMemory(vulkanGetProcAddress('vkBindBufferMemory', Vulkan_LibHandle));
    vkBindImageMemory := TvkBindImageMemory(vulkanGetProcAddress('vkBindImageMemory', Vulkan_LibHandle));
    vkGetBufferMemoryRequirements := TvkGetBufferMemoryRequirements(vulkanGetProcAddress('vkGetBufferMemoryRequirements', Vulkan_LibHandle));
    vkGetImageMemoryRequirements := TvkGetImageMemoryRequirements(vulkanGetProcAddress('vkGetImageMemoryRequirements', Vulkan_LibHandle));
    vkGetImageSparseMemoryRequirements := TvkGetImageSparseMemoryRequirements(vulkanGetProcAddress('vkGetImageSparseMemoryRequirements', Vulkan_LibHandle));
    vkGetPhysicalDeviceSparseImageFormatProperties := TvkGetPhysicalDeviceSparseImageFormatProperties(vulkanGetProcAddress('vkGetPhysicalDeviceSparseImageFormatProperties', Vulkan_LibHandle));
    vkQueueBindSparse := TvkQueueBindSparse(vulkanGetProcAddress('vkQueueBindSparse', Vulkan_LibHandle));
    vkCreateFence := TvkCreateFence(vulkanGetProcAddress('vkCreateFence', Vulkan_LibHandle));
    vkDestroyFence := TvkDestroyFence(vulkanGetProcAddress('vkDestroyFence', Vulkan_LibHandle));
    vkResetFences := TvkResetFences(vulkanGetProcAddress('vkResetFences', Vulkan_LibHandle));
    vkGetFenceStatus := TvkGetFenceStatus(vulkanGetProcAddress('vkGetFenceStatus', Vulkan_LibHandle));
    vkWaitForFences := TvkWaitForFences(vulkanGetProcAddress('vkWaitForFences', Vulkan_LibHandle));
    vkCreateSemaphore := TvkCreateSemaphore(vulkanGetProcAddress('vkCreateSemaphore', Vulkan_LibHandle));
    vkDestroySemaphore := TvkDestroySemaphore(vulkanGetProcAddress('vkDestroySemaphore', Vulkan_LibHandle));
    vkCreateEvent := TvkCreateEvent(vulkanGetProcAddress('vkCreateEvent', Vulkan_LibHandle));
    vkDestroyEvent := TvkDestroyEvent(vulkanGetProcAddress('vkDestroyEvent', Vulkan_LibHandle));
    vkGetEventStatus := TvkGetEventStatus(vulkanGetProcAddress('vkGetEventStatus', Vulkan_LibHandle));
    vkSetEvent := TvkSetEvent(vulkanGetProcAddress('vkSetEvent', Vulkan_LibHandle));
    vkResetEvent := TvkResetEvent(vulkanGetProcAddress('vkResetEvent', Vulkan_LibHandle));
    vkCreateQueryPool := TvkCreateQueryPool(vulkanGetProcAddress('vkCreateQueryPool', Vulkan_LibHandle));
    vkDestroyQueryPool := TvkDestroyQueryPool(vulkanGetProcAddress('vkDestroyQueryPool', Vulkan_LibHandle));
    vkGetQueryPoolResults := TvkGetQueryPoolResults(vulkanGetProcAddress('vkGetQueryPoolResults', Vulkan_LibHandle));
    vkCreateBuffer := TvkCreateBuffer(vulkanGetProcAddress('vkCreateBuffer', Vulkan_LibHandle));
    vkDestroyBuffer := TvkDestroyBuffer(vulkanGetProcAddress('vkDestroyBuffer', Vulkan_LibHandle));
    vkCreateBufferView := TvkCreateBufferView(vulkanGetProcAddress('vkCreateBufferView', Vulkan_LibHandle));
    vkDestroyBufferView := TvkDestroyBufferView(vulkanGetProcAddress('vkDestroyBufferView', Vulkan_LibHandle));
    vkCreateImage := TvkCreateImage(vulkanGetProcAddress('vkCreateImage', Vulkan_LibHandle));
    vkDestroyImage := TvkDestroyImage(vulkanGetProcAddress('vkDestroyImage', Vulkan_LibHandle));
    vkGetImageSubresourceLayout := TvkGetImageSubresourceLayout(vulkanGetProcAddress('vkGetImageSubresourceLayout', Vulkan_LibHandle));
    vkCreateImageView := TvkCreateImageView(vulkanGetProcAddress('vkCreateImageView', Vulkan_LibHandle));
    vkDestroyImageView := TvkDestroyImageView(vulkanGetProcAddress('vkDestroyImageView', Vulkan_LibHandle));
    vkCreateShaderModule := TvkCreateShaderModule(vulkanGetProcAddress('vkCreateShaderModule', Vulkan_LibHandle));
    vkDestroyShaderModule := TvkDestroyShaderModule(vulkanGetProcAddress('vkDestroyShaderModule', Vulkan_LibHandle));
    vkCreatePipelineCache := TvkCreatePipelineCache(vulkanGetProcAddress('vkCreatePipelineCache', Vulkan_LibHandle));
    vkDestroyPipelineCache := TvkDestroyPipelineCache(vulkanGetProcAddress('vkDestroyPipelineCache', Vulkan_LibHandle));
    vkGetPipelineCacheData := TvkGetPipelineCacheData(vulkanGetProcAddress('vkGetPipelineCacheData', Vulkan_LibHandle));
    vkMergePipelineCaches := TvkMergePipelineCaches(vulkanGetProcAddress('vkMergePipelineCaches', Vulkan_LibHandle));
    vkCreateGraphicsPipelines := TvkCreateGraphicsPipelines(vulkanGetProcAddress('vkCreateGraphicsPipelines', Vulkan_LibHandle));
    vkCreateComputePipelines := TvkCreateComputePipelines(vulkanGetProcAddress('vkCreateComputePipelines', Vulkan_LibHandle));
    vkDestroyPipeline := TvkDestroyPipeline(vulkanGetProcAddress('vkDestroyPipeline', Vulkan_LibHandle));
    vkCreatePipelineLayout := TvkCreatePipelineLayout(vulkanGetProcAddress('vkCreatePipelineLayout', Vulkan_LibHandle));
    vkDestroyPipelineLayout := TvkDestroyPipelineLayout(vulkanGetProcAddress('vkDestroyPipelineLayout', Vulkan_LibHandle));
    vkCreateSampler := TvkCreateSampler(vulkanGetProcAddress('vkCreateSampler', Vulkan_LibHandle));
    vkDestroySampler := TvkDestroySampler(vulkanGetProcAddress('vkDestroySampler', Vulkan_LibHandle));
    vkCreateDescriptorSetLayout := TvkCreateDescriptorSetLayout(vulkanGetProcAddress('vkCreateDescriptorSetLayout', Vulkan_LibHandle));
    vkDestroyDescriptorSetLayout := TvkDestroyDescriptorSetLayout(vulkanGetProcAddress('vkDestroyDescriptorSetLayout', Vulkan_LibHandle));
    vkCreateDescriptorPool := TvkCreateDescriptorPool(vulkanGetProcAddress('vkCreateDescriptorPool', Vulkan_LibHandle));
    vkDestroyDescriptorPool := TvkDestroyDescriptorPool(vulkanGetProcAddress('vkDestroyDescriptorPool', Vulkan_LibHandle));
    vkResetDescriptorPool := TvkResetDescriptorPool(vulkanGetProcAddress('vkResetDescriptorPool', Vulkan_LibHandle));
    vkAllocateDescriptorSets := TvkAllocateDescriptorSets(vulkanGetProcAddress('vkAllocateDescriptorSets', Vulkan_LibHandle));
    vkFreeDescriptorSets := TvkFreeDescriptorSets(vulkanGetProcAddress('vkFreeDescriptorSets', Vulkan_LibHandle));
    vkUpdateDescriptorSets := TvkUpdateDescriptorSets(vulkanGetProcAddress('vkUpdateDescriptorSets', Vulkan_LibHandle));
    vkCreateFramebuffer := TvkCreateFramebuffer(vulkanGetProcAddress('vkCreateFramebuffer', Vulkan_LibHandle));
    vkDestroyFramebuffer := TvkDestroyFramebuffer(vulkanGetProcAddress('vkDestroyFramebuffer', Vulkan_LibHandle));
    vkCreateRenderPass := TvkCreateRenderPass(vulkanGetProcAddress('vkCreateRenderPass', Vulkan_LibHandle));
    vkDestroyRenderPass := TvkDestroyRenderPass(vulkanGetProcAddress('vkDestroyRenderPass', Vulkan_LibHandle));
    vkGetRenderAreaGranularity := TvkGetRenderAreaGranularity(vulkanGetProcAddress('vkGetRenderAreaGranularity', Vulkan_LibHandle));
    vkCreateCommandPool := TvkCreateCommandPool(vulkanGetProcAddress('vkCreateCommandPool', Vulkan_LibHandle));
    vkDestroyCommandPool := TvkDestroyCommandPool(vulkanGetProcAddress('vkDestroyCommandPool', Vulkan_LibHandle));
    vkResetCommandPool := TvkResetCommandPool(vulkanGetProcAddress('vkResetCommandPool', Vulkan_LibHandle));
    vkAllocateCommandBuffers := TvkAllocateCommandBuffers(vulkanGetProcAddress('vkAllocateCommandBuffers', Vulkan_LibHandle));
    vkFreeCommandBuffers := TvkFreeCommandBuffers(vulkanGetProcAddress('vkFreeCommandBuffers', Vulkan_LibHandle));
    vkBeginCommandBuffer := TvkBeginCommandBuffer(vulkanGetProcAddress('vkBeginCommandBuffer', Vulkan_LibHandle));
    vkEndCommandBuffer := TvkEndCommandBuffer(vulkanGetProcAddress('vkEndCommandBuffer', Vulkan_LibHandle));
    vkResetCommandBuffer := TvkResetCommandBuffer(vulkanGetProcAddress('vkResetCommandBuffer', Vulkan_LibHandle));
    vkCmdBindPipeline := TvkCmdBindPipeline(vulkanGetProcAddress('vkCmdBindPipeline', Vulkan_LibHandle));
    vkCmdSetViewport := TvkCmdSetViewport(vulkanGetProcAddress('vkCmdSetViewport', Vulkan_LibHandle));
    vkCmdSetScissor := TvkCmdSetScissor(vulkanGetProcAddress('vkCmdSetScissor', Vulkan_LibHandle));
    vkCmdSetLineWidth := TvkCmdSetLineWidth(vulkanGetProcAddress('vkCmdSetLineWidth', Vulkan_LibHandle));
    vkCmdSetDepthBias := TvkCmdSetDepthBias(vulkanGetProcAddress('vkCmdSetDepthBias', Vulkan_LibHandle));
    vkCmdSetBlendConstants := TvkCmdSetBlendConstants(vulkanGetProcAddress('vkCmdSetBlendConstants(vulkanGetProcAddress', Vulkan_LibHandle));
    vkCmdSetDepthBounds := TvkCmdSetDepthBounds(vulkanGetProcAddress('vkCmdSetDepthBounds', Vulkan_LibHandle));
    vkCmdSetStencilCompareMask := TvkCmdSetStencilCompareMask(vulkanGetProcAddress('vkCmdSetStencilCompareMask', Vulkan_LibHandle));
    vkCmdSetStencilWriteMask := TvkCmdSetStencilWriteMask(vulkanGetProcAddress('vkCmdSetStencilWriteMask', Vulkan_LibHandle));
    vkCmdSetStencilReference := TvkCmdSetStencilReference(vulkanGetProcAddress('vkCmdSetStencilReference', Vulkan_LibHandle));
    vkCmdBindDescriptorSets := TvkCmdBindDescriptorSets(vulkanGetProcAddress('vkCmdBindIndexBuffer', Vulkan_LibHandle));
    vkCmdBindIndexBuffer := TvkCmdBindIndexBuffer(vulkanGetProcAddress('vkCmdBindIndexBuffer', Vulkan_LibHandle));
    vkCmdBindVertexBuffers := TvkCmdBindVertexBuffers(vulkanGetProcAddress('vkCmdBindVertexBuffers', Vulkan_LibHandle));
    vkCmdDraw := TvkCmdDraw(vulkanGetProcAddress('vkCmdDraw', Vulkan_LibHandle));
    vkCmdDrawIndexed := TvkCmdDrawIndexed(vulkanGetProcAddress('vkCmdDrawIndexed', Vulkan_LibHandle));
    vkCmdDrawIndirect := TvkCmdDrawIndirect(vulkanGetProcAddress('vkCmdDrawIndirect', Vulkan_LibHandle));
    vkCmdDrawIndexedIndirect := TvkCmdDrawIndexedIndirect(vulkanGetProcAddress('vkCmdDrawIndexedIndirect', Vulkan_LibHandle));
    vkCmdDispatch := TvkCmdDispatch(vulkanGetProcAddress('vkCmdDispatch', Vulkan_LibHandle));
    vkCmdDispatchIndirect := TvkCmdDispatchIndirect(vulkanGetProcAddress('vkCmdDispatchIndirect', Vulkan_LibHandle));
    vkCmdCopyBuffer := TvkCmdCopyBuffer(vulkanGetProcAddress('vkCmdCopyBuffer', Vulkan_LibHandle));
    vkCmdCopyImage := TvkCmdCopyImage(vulkanGetProcAddress('vkCmdCopyImage', Vulkan_LibHandle));
    vkCmdBlitImage := TvkCmdBlitImage(vulkanGetProcAddress('vkCmdBlitImage', Vulkan_LibHandle));
    vkCmdCopyBufferToImage := TvkCmdCopyBufferToImage(vulkanGetProcAddress('vkCmdCopyBufferToImage', Vulkan_LibHandle));
    vkCmdCopyImageToBuffer := TvkCmdCopyImageToBuffer(vulkanGetProcAddress('vkCmdCopyImageToBuffer', Vulkan_LibHandle));
    vkCmdUpdateBuffer := TvkCmdUpdateBuffer(vulkanGetProcAddress('vkCmdUpdateBuffer', Vulkan_LibHandle));
    vkCmdFillBuffer := TvkCmdFillBuffer(vulkanGetProcAddress('vkCmdFillBuffer', Vulkan_LibHandle));
    vkCmdClearColorImage := TvkCmdClearColorImage(vulkanGetProcAddress('vkCmdClearColorImage', Vulkan_LibHandle));
    vkCmdClearDepthStencilImage := TvkCmdClearDepthStencilImage(vulkanGetProcAddress('vkCmdClearDepthStencilImage', Vulkan_LibHandle));
    vkCmdClearAttachments := TvkCmdClearAttachments(vulkanGetProcAddress('vkCmdClearAttachments', Vulkan_LibHandle));
    vkCmdResolveImage := TvkCmdResolveImage(vulkanGetProcAddress('vkCmdResolveImage', Vulkan_LibHandle));
    vkCmdSetEvent := TvkCmdSetEvent(vulkanGetProcAddress('vkCmdSetEvent', Vulkan_LibHandle));
    vkCmdResetEvent := TvkCmdResetEvent(vulkanGetProcAddress('vkCmdResetEvent', Vulkan_LibHandle));
    vkCmdWaitEvents := TvkCmdWaitEvents(vulkanGetProcAddress('vkCmdWaitEvents', Vulkan_LibHandle));
    vkCmdPipelineBarrier := TvkCmdPipelineBarrier(vulkanGetProcAddress('vkCmdPipelineBarrier', Vulkan_LibHandle));
    vkCmdBeginQuery := TvkCmdBeginQuery(vulkanGetProcAddress('vkCmdBeginQuery', Vulkan_LibHandle));
    vkCmdEndQuery := TvkCmdEndQuery(vulkanGetProcAddress('vkCmdEndQuery', Vulkan_LibHandle));
    vkCmdResetQueryPool := TvkCmdResetQueryPool(vulkanGetProcAddress('vkCmdResetQueryPool', Vulkan_LibHandle));
    vkCmdWriteTimestamp := TvkCmdWriteTimestamp(vulkanGetProcAddress('vkCmdWriteTimestamp', Vulkan_LibHandle));
    vkCmdCopyQueryPoolResults := TvkCmdCopyQueryPoolResults(vulkanGetProcAddress('', Vulkan_LibHandle));
    vkCmdPushConstants := TvkCmdPushConstants(vulkanGetProcAddress('vkCmdPushConstants', Vulkan_LibHandle));
    vkCmdBeginRenderPass := TvkCmdBeginRenderPass(vulkanGetProcAddress('vkCmdBeginRenderPass', Vulkan_LibHandle));
    vkCmdNextSubpass := TvkCmdNextSubpass(vulkanGetProcAddress('vkCmdNextSubpass', Vulkan_LibHandle));
    vkCmdEndRenderPass := TvkCmdEndRenderPass(vulkanGetProcAddress('vkCmdEndRenderPass', Vulkan_LibHandle));
    vkCmdExecuteCommands := TvkCmdExecuteCommands(vulkanGetProcAddress('vkCmdExecuteCommands', Vulkan_LibHandle));

    Result := True;
  end;
end;
end.
